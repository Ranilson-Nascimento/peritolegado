<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ Sistema de Migra√ß√£o Inteligente - Perito Legado</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Card Layout Padr√£o Compacto */
        .card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .card-header {
            background: #667eea;
            color: white;
            padding: 12px 16px;
            margin: -16px -16px 16px -16px;
            border-radius: 8px 8px 0 0;
            font-size: 1rem;
            font-weight: 600;
        }

        /* Content Areas - Espa√ßamento Padr√£o */
        .content-section {
            margin-bottom: 20px;
        }

        .section-title {
            color: #333;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #667eea;
        }

        .section-content {
            padding: 12px 0;
        }

        /* Grid Layouts Padr√£o */
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
        }

        .grid-4 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        @media (max-width: 1200px) {
            .grid-2, .grid-3, .grid-4 {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 20px;
                max-width: 100%;
            }
        }

        /* Navigation Bar - Compacto e Responsivo */
        .nav-bar {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 10px 20px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .nav-brand {
            color: white;
            font-weight: 700;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            padding: 6px 12px;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }

        .nav-link:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }

        .nav-link.active {
            background: rgba(255,255,255,0.3);
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .nav-bar {
                flex-direction: column;
                text-align: center;
            }
            
            .nav-links {
                justify-content: center;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            color: white;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .header p {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .main-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .tab {
            flex: 1;
            padding: 8px 12px;
            text-align: center;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
            font-size: 0.85rem;
        }

        .tab.active {
            background: white;
            border-bottom-color: #667eea;
            color: #667eea;
        }

        .tab-content {
            display: none;
            padding: 24px;
            min-height: 400px;
        }

        .tab-content.active {
            display: block;
        }

        /* Connection Tab - Layout Padr√£o */
        .connection-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 24px;
        }

        @media (max-width: 1024px) {
            .connection-section {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }

        .connection-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .connection-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.15);
        }

        .connection-card h3 {
            color: #667eea;
            margin-bottom: 16px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* Connection Form Groups - Espa√ßamento compacto */
        .connection-card .form-group {
            margin-bottom: 8px;
        }

        .connection-card .form-group:last-child {
            margin-bottom: 0;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #333;
            font-size: 0.9rem;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.2s;
            background: white;
        }

        .form-group select {
            cursor: pointer;
            appearance: auto;
            -webkit-appearance: menulist;
            -moz-appearance: menulist;
            background: white;
            border: 1px solid #ddd;
            font-weight: normal;
        }

        .form-group select:hover {
            border-color: #667eea;
        }

        .form-group select option {
            padding: 8px 12px;
            background: white;
            color: #333;
            font-weight: normal;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .path-input-container {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .path-input-container input {
            flex: 1;
            background: #f8f9fa;
            cursor: pointer;
            min-width: 200px;
        }

        .path-input-container button {
            white-space: nowrap;
            min-width: 120px;
        }

        .path-input-container input:hover {
            background: #e9ecef;
        }

        .recent-files-section {
            margin-bottom: 20px;
        }

        .recent-files-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
        }

        .recent-files-list {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: white;
        }

        .recent-file-item {
            padding: 8px 12px;
            border-bottom: 1px solid #f1f3f4;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .recent-file-item:hover {
            background: #f8f9fa;
            color: #667eea;
        }

        .recent-file-item:last-child {
            border-bottom: none;
        }

        .recent-file-path {
            font-size: 0.85rem;
            color: #6c757d;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .recent-file-date {
            font-size: 0.75rem;
            color: #adb5bd;
            margin-left: 10px;
        }

        .file-explorer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-explorer-content {
            background: white;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            height: 80%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        .file-explorer-header {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-explorer-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #495057;
        }

        .close-explorer {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .close-explorer:hover {
            background: #f8f9fa;
            color: #495057;
        }

        .file-explorer-navigation {
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
        }

        .nav-button {
            background: #e9ecef;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .nav-button:hover {
            background: #dee2e6;
        }

        .nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .current-path {
            flex: 1;
            padding: 8px 12px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .file-explorer-body {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .file-list {
            display: grid;
            gap: 5px;
        }

        .file-item {
            padding: 12px 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .file-item:hover {
            background: #f8f9fa;
            border-color: #667eea;
        }

        .file-item.selected {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .file-item.folder {
            background: #f0f4ff;
        }

        .file-item.folder:hover {
            background: #e3f2fd;
        }

        .file-icon {
            font-size: 1.2rem;
            width: 20px;
            text-align: center;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            color: #495057;
        }

        .file-details {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 2px;
        }

        .file-explorer-footer {
            padding: 20px;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
        }

        .selected-file-info {
            flex: 1;
            font-size: 0.9rem;
            color: #495057;
        }

        .explorer-actions {
            display: flex;
            gap: 10px;
        }

        .database-list {
            display: grid;
            gap: 10px;
        }

        .database-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .database-item:hover {
            border-color: #667eea;
            background: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .database-icon {
            font-size: 2rem;
            margin-right: 15px;
            min-width: 50px;
            text-align: center;
        }

        .database-info {
            flex: 1;
        }

        .database-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 5px;
        }

        .database-path {
            font-size: 0.9rem;
            color: #6c757d;
            margin-bottom: 8px;
            font-family: monospace;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }

        .database-details {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            color: #adb5bd;
        }

        .database-size,
        .database-date,
        .database-type {
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 12px;
        }

        .database-actions {
            margin-left: 15px;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 0.85rem;
        }

        .search-result-item:hover {
            background: #f8f9fa !important;
            border-color: #667eea !important;
        }

        @media (max-width: 768px) {
            .file-explorer-content {
                width: 95%;
                height: 90%;
            }
            
            .database-item {
                flex-direction: column;
                text-align: center;
            }
            
            .database-icon {
                margin-right: 0;
                margin-bottom: 10px;
            }
            
            .database-details {
                flex-direction: column;
                gap: 5px;
            }
            
            .connection-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .path-input-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .path-input-container input {
                margin-bottom: 10px;
            }
            
            .path-input-container button {
                width: 100%;
                justify-content: center;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                width: 100%;
                text-align: center;
            }
            
            .form-group {
                margin-bottom: 20px;
            }
            
            .connection-card {
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .connection-card h3 {
                font-size: 1.2rem;
            }
            
            .modal-content {
                padding: 15px;
                margin: 10px;
            }
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-purple {
            background: #6f42c1;
        }

        .btn-purple:hover {
            background: #5a32a3;
        }

        /* Button Groups - Layout Padr√£o */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-top: 20px;
        }

        .button-group .btn {
            margin: 0;
            flex: 0 0 auto;
        }

        .button-group.center {
            justify-content: center;
        }

        .button-group.end {
            justify-content: flex-end;
        }

        .button-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
            align-items: center;
        }

        .button-toolbar .button-group {
            margin: 0;
        }

        .mt-15 {
            margin-top: 10px;
        }

        /* Connection Tab - Bot√µes sempre horizontais em telas grandes */
        .connection-card .button-group {
            margin-bottom: 6px;
            justify-content: flex-start;
            flex-direction: row;
        }

        .connection-card .button-group .btn {
            font-size: 0.75rem;
            padding: 5px 8px;
            min-width: 85px;
            margin: 2px;
            flex: 0 0 auto;
        }

        @media (max-width: 768px) {
            .button-group {
                gap: 8px;
            }
            
            .button-group .btn {
                font-size: 0.8rem;
                padding: 8px 12px;
            }
            
            .connection-section {
                grid-template-columns: 1fr;
            }
        }

        /* Mapping Tab - Layout Ultra Compacto e Responsivo */
        .mapping-container {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 8px;
            align-items: start;
            min-height: 280px;
            margin-bottom: 10px;
        }

        .schema-panel {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #e9ecef;
            height: 400px;
            overflow-y: auto;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }

        .schema-panel:hover {
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }

        .schema-panel h3 {
            color: #667eea;
            margin-bottom: 6px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 4px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 4px;
            margin: -12px -12px 12px -12px;
        }

        .table-search {
            width: 100%;
            padding: 8px 32px 8px 12px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.85rem;
            margin-bottom: 12px;
            background: white;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            position: relative;
        }

        .table-search:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            outline: none;
        }

        .table-search::placeholder {
            color: #adb5bd;
            font-style: italic;
        }

        .search-container {
            position: relative;
        }

        .clear-search {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #adb5bd;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 4px;
            border-radius: 50%;
            transition: all 0.3s ease;
            display: none;
        }

        .clear-search:hover {
            background: #f8f9fa;
            color: #667eea;
        }

        .clear-search.show {
            display: block;
        }

        .table-list {
            min-height: 80px;
            padding: 4px;
        }

        .table-item {
            background: white;
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 6px;
            border: 1px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 1px 4px rgba(0,0,0,0.05);
        }

        .table-item:hover {
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.15);
        }

        .table-item.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f4ff 0%, #e8f2ff 100%);
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.2);
        }

        .table-item.multi-selected {
            border-color: #28a745;
            background: linear-gradient(135deg, #f0fff4 0%, #e8f8e8 100%);
            box-shadow: 0 3px 8px rgba(40, 167, 69, 0.2);
        }

        .table-item.target-selected {
            border-color: #ffc107;
            background: linear-gradient(135deg, #fffbf0 0%, #fff8e1 100%);
            box-shadow: 0 3px 8px rgba(255, 193, 7, 0.2);
        }

        .multi-select-indicator {
            position: absolute;
            top: 6px;
            right: 6px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            box-shadow: 0 1px 4px rgba(40, 167, 69, 0.3);
        }

        .table-item.dragging {
            opacity: 0.7;
            transform: rotate(3deg) scale(0.98);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .table-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 6px;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .table-name::before {
            content: "üìã";
            font-size: 1rem;
        }

        .table-info {
            font-size: 0.8rem;
            color: #6c757d;
            background: #f8f9fa;
            padding: 6px 8px;
            border-radius: 6px;
            margin-top: 6px;
            border-left: 2px solid #dee2e6;
        }

        .table-columns-preview {
            margin-top: 8px;
            padding: 6px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .table-columns-preview h6 {
            margin: 0 0 6px 0;
            font-size: 0.8rem;
            color: #667eea;
            font-weight: 600;
        }

        .columns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 4px;
        }

        .column-preview {
            background: white;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            border: 1px solid #dee2e6;
            text-align: center;
        }

        .column-preview .column-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 2px;
        }

        .column-preview .column-type {
            color: #6c757d;
            font-size: 0.65rem;
        }

        .mapping-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 8px 6px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 6px;
            border: 1px solid #e9ecef;
            min-height: 200px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .mapping-controls h4 {
            color: #667eea;
            text-align: center;
            margin-bottom: 6px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        /* Fix button-group dentro do mapping-controls */
        .mapping-controls .button-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            width: 100%;
            align-items: center;
        }

        .mapping-controls .button-group .btn {
            width: 120px;
            padding: 5px 8px;
            font-size: 0.7rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            line-height: 1.2;
        }

        .mapping-controls .button-group .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }

        .advanced-mapping-section {
            border-top: 1px solid #e0e0e0;
            padding-top: 20px;
            margin-top: 20px;
            width: 100%;
            text-align: center;
        }

        .advanced-mapping-section h4 {
            color: #667eea;
            margin-bottom: 16px;
            font-size: 1rem;
            font-weight: 600;
        }

        .advanced-mapping-section .btn {
            margin: 4px;
            padding: 8px 16px;
            font-size: 0.9rem;
            min-width: auto;
            max-width: none;
            border-radius: 6px;
        }

        .mapping-arrow {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
            margin: 8px 0;
        }

        .mapping-arrow:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .mapping-arrow:active {
            transform: scale(1.05);
        }

        /* Button Styles - Layout Ultra Compacto e Responsivo */
        .btn {
            padding: 6px 12px;
            border-radius: 8px;
            border: none;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-width: 70px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin: 2px;
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.12);
        }

        .btn:active {
            transform: translateY(0px);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #228a3e 0%, #1bb885 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
        }

        .btn-warning:hover {
            background: linear-gradient(135deg, #e0a800 0%, #e76500 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #e83e8c 100%);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c92a3b 0%, #d6347a 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #6f42c1 100%);
            color: white;
        }

        .btn-info:hover {
            background: linear-gradient(135deg, #148ea1 0%, #5f37a6 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #adb5bd 100%);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #5a6268 0%, #9ca3af 100%);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #667eea;
            color: #667eea;
        }

        .btn-outline:hover {
            background: #667eea;
            color: white;
        }

        /* Action Sections - Layout Horizontal Compacto */
        .action-section {
            background: white;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #e9ecef;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .action-group {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-start;
            align-items: center;
            margin: 5px 0;
        }

        .action-group .btn {
            margin: 1px;
            min-width: 90px;
            flex: 0 0 auto;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-start;
            margin: 8px 0;
        }

        .button-row .btn {
            flex: 0 0 auto;
            min-width: 90px;
            max-width: 140px;
        }

        /* Statistics & Results - Layout Horizontal Otimizado */
        .statistics-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-bottom: 10px;
        }

        .stat-card {
            background: white;
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }

        .stat-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            border-color: #667eea;
        }

        .stat-card .stat-icon {
            font-size: 1.5rem;
            margin-bottom: 4px;
            display: block;
        }

        .stat-card .stat-value {
            font-size: 1.3rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 2px;
        }

        .stat-card .stat-label {
            font-size: 0.75rem;
            color: #6c757d;
            font-weight: 400;
        }

        .results-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            border: 1px solid #e9ecef;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 8px;
        }

        .result-card {
            background: white;
            border-radius: 6px;
            padding: 10px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }

        .result-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            border-color: #667eea;
        }

        /* Form Controls - Layout Ultra Compacto */
        .form-group {
            margin-bottom: 8px;
        }

        .form-group label {
            font-weight: 500;
            color: #495057;
            margin-bottom: 3px;
            display: block;
            font-size: 0.85rem;
        }

        .form-control {
            border-radius: 6px;
            border: 1px solid #e9ecef;
            padding: 6px 10px;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
            width: 100%;
        }

        .form-control:focus {
            border-color: #667eea;
            box-shadow: 0 1px 4px rgba(102, 126, 234, 0.12);
            outline: none;
        }

        .form-control:hover {
            border-color: #ced4da;
        }

        .form-text {
            color: #6c757d;
            font-size: 0.8rem;
            margin-top: 4px;
            display: block;
            line-height: 1.3;
        }

        /* Alert Messages - Layout Ultra Compacto */
        .alert {
            border-radius: 6px;
            padding: 8px 12px;
            margin: 8px 0;
            border: 1px solid;
            font-size: 0.8rem;
            line-height: 1.3;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }

        .alert-success {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border-color: #c3e6cb;
            color: #155724;
        }

        .alert-warning {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border-color: #ffeaa7;
            color: #856404;
        }

        .alert-danger {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            border-color: #f5c6cb;
            color: #721c24;
        }

        .alert-info {
            background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
            border-color: #bee5eb;
            color: #0c5460;
        }

        /* Responsive Layout - Mobile Ultra Otimizado */
        @media (max-width: 768px) {
            .container {
                padding: 8px;
            }
            
            .mapping-container {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .schema-panel {
                height: 350px;
            }
            
            .action-group,
            .button-row {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: flex-start;
            }
            
            .action-group .btn,
            .button-row .btn {
                flex: 0 0 auto;
                min-width: 80px;
                max-width: 120px;
                margin: 2px;
            }
            
            .grid-2, .grid-3, .grid-4 {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 6px;
            }
            
            .connection-section {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .nav-bar {
                padding: 10px 15px;
                gap: 10px;
            }
            
            .nav-links {
                gap: 8px;
            }
            
            .nav-link {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            
            .form-group {
                margin-bottom: 10px;
            }
            
            .btn {
                padding: 6px 10px;
                font-size: 0.75rem;
                min-width: 70px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 6px;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .btn {
                padding: 5px 8px;
                font-size: 0.7rem;
                min-width: 60px;
            }
            
            .connection-card h3 {
                font-size: 0.9rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 4px;
            }
            
            .stat-card {
                padding: 6px;
            }
            
            .stat-card .stat-value {
                font-size: 1.1rem;
            }
            
            .stat-card .stat-label {
                font-size: 0.7rem;
            }
            
            .action-group .btn,
            .button-row .btn {
                min-width: 70px;
                max-width: 100px;
                font-size: 0.7rem;
            }
        }

        /* Mapping List */
        .mapping-list {
            margin-top: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
        }

        .mapping-list .button-group {
            margin-bottom: 20px;
        }

        .mapping-item {
            background: white;
            border-radius: 4px;
            padding: 6px 8px;
            margin-bottom: 4px;
            border: 1px solid #e9ecef;
            position: relative;
            font-size: 0.8rem;
        }

        .mapping-item.many-to-one {
            border-left: 3px solid #28a745;
        }

        .mapping-item.one-to-many {
            border-left: 3px solid #ffc107;
        }

        .mapping-item.one-to-one {
            border-left: 3px solid #667eea;
        }

        .mapping-type-badge {
            position: absolute;
            top: 3px;
            right: 3px;
            background: #667eea;
            color: white;
            padding: 1px 4px;
            border-radius: 4px;
            font-size: 0.6rem;
            font-weight: 600;
        }

        .mapping-type-badge.many-to-one {
            background: #28a745;
        }

        .mapping-type-badge.one-to-many {
            background: #ffc107;
            color: #333;
        }

        .paradox-transformation-indicator {
            display: inline-block;
            background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%);
            color: white;
            padding: 1px 4px;
            border-radius: 6px;
            font-size: 0.65rem;
            margin-left: 4px;
        }

        .mapping-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 8px;
        }

        .mapping-title {
            font-weight: 600;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        .confidence-badge {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .confidence-badge.medium {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
        }

        .confidence-badge.low {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .validation-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-align: center;
            min-width: 80px;
        }

        .validation-badge.validated {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            box-shadow: 0 2px 6px rgba(0, 123, 255, 0.3);
            animation: glow-validated 3s ease-in-out infinite alternate;
        }

        .validation-badge.pending {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #333;
        }

        @keyframes glow-validated {
            from { box-shadow: 0 2px 6px rgba(0, 123, 255, 0.3); }
            to { box-shadow: 0 4px 12px rgba(0, 123, 255, 0.6); }
        }

        .mapping-item.validated-mapping {
            border-left: 4px solid #007bff;
            background: linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 100%);
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.15);
        }

        .column-mappings {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 6px;
            align-items: center;
            font-size: 0.8rem;
        }

        .column-source,
        .column-target {
            padding: 6px 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }

        .column-arrow {
            color: #667eea;
            font-weight: bold;
        }

        /* Status and Progress */
        .status-panel {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
            min-width: 250px;
            max-width: 300px;
            z-index: 1000;
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .status-title {
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #28a745;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .mapping-container {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .connection-section {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 8px;
            }

            .header h1 {
                font-size: 1.6rem;
            }

            .status-panel {
                position: relative;
                bottom: auto;
                right: auto;
                margin-top: 15px;
                min-width: auto;
            }

            .schema-panel {
                height: 240px;
            }

            .mapping-container {
                min-height: 240px;
            }
        }

        /* Drag and Drop */
        .drop-zone {
            border: 2px dashed #667eea;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            color: #667eea;
            background: rgba(102, 126, 234, 0.05);
            transition: all 0.3s ease;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
        }

        .drop-zone.drag-over {
            background: rgba(102, 126, 234, 0.1);
            border-color: #5a6acf;
        }

        /* Tabelas Mapeadas - Indicadores Visuais */
        .table-item.mapped {
            border: 2px solid #28a745;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            position: relative;
        }

        .table-item.mapped::after {
            content: "‚úÖ";
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
        }

        .table-item.partially-mapped {
            border: 2px solid #ffc107;
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            position: relative;
        }

        .table-item.partially-mapped::after {
            content: "‚ö†Ô∏è";
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
        }

        .table-item.validated {
            border: 3px solid #007bff;
            background: linear-gradient(135deg, #cce7ff 0%, #b3d9ff 100%);
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }

        .table-item.validated::after {
            content: "üéØ";
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
            animation: pulse-validated 2s infinite;
        }

        @keyframes pulse-validated {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .table-item.validated::before {
            content: "VALIDADO";
            position: absolute;
            bottom: 5px;
            left: 5px;
            background: #007bff;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.6rem;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        /* Destacar tabelas dispon√≠veis para mapeamento */
        .table-item.highlight-unmapped {
            border: 2px solid #28a745;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            animation: highlight-pulse 2s ease-in-out infinite;
            position: relative;
        }

        .table-item.highlight-unmapped::before {
            content: "DISPON√çVEL";
            position: absolute;
            top: 5px;
            right: 5px;
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.6rem;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .table-item.highlight-unmapped::after {
            content: "üëÜ";
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 16px;
            animation: bounce-highlight 1s ease-in-out infinite;
        }

        @keyframes highlight-pulse {
            0% { box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3); }
            50% { box-shadow: 0 6px 18px rgba(40, 167, 69, 0.5); }
            100% { box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3); }
        }

        @keyframes bounce-highlight {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        /* Sistema de Mapeamento de Colunas */
        .mapping-progress-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .progress-stats {
            display: flex;
            gap: 16px;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .progress-stats span {
            padding: 4px 12px;
            background: white;
            border-radius: 20px;
            border: 1px solid #dee2e6;
            color: #495057;
        }

        .current-selection {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #667eea;
            font-weight: 500;
        }

        .current-selection span:last-child {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: 600;
        }

        /* Sistema de Mapeamento de Colunas */
        .column-mapping-interface {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            border: 1px solid #e9ecef;
        }

        .columns-container {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 12px;
            align-items: start;
        }

        .column-list {
            background: white;
            border-radius: 6px;
            padding: 10px;
            border: 1px solid #dee2e6;
            min-height: 200px;
        }

        .column-list h4 {
            margin: 0 0 8px 0;
            color: #495057;
            font-size: 0.9rem;
            padding-bottom: 6px;
            border-bottom: 2px solid #e9ecef;
        }

        .column-item {
            background: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 6px 8px;
            margin-bottom: 6px;
            cursor: move;
            transition: all 0.3s ease;
            position: relative;
        }

        .column-item:hover {
            background: #f8f9fa;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.15);
        }

        .column-item.dragging {
            opacity: 0.5;
            transform: rotate(3deg);
        }

        .column-item.mapped {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border-color: #28a745;
        }

        .column-item.mapped::after {
            content: "‚úì";
            position: absolute;
            top: 3px;
            right: 6px;
            color: #28a745;
            font-weight: bold;
        }

        .column-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 3px;
            font-size: 0.85rem;
        }

        .column-type {
            font-size: 0.75rem;
            color: #6c757d;
            background: #e9ecef;
            padding: 1px 4px;
            border-radius: 3px;
            display: inline-block;
        }

        .mapping-arrow-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px 0;
        }

        .mapping-arrow {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            margin: 8px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }

        .mapping-arrow:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        /* Mapeamentos Configurados - Removido (usando button-group padr√£o) */
        /*
        .mapping-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            gap: 16px;
        }

        .view-toggle {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .view-toggle .btn {
            padding: 8px 12px;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
            min-width: auto;
            max-width: none;
            white-space: nowrap;
        }

        .view-toggle .btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        */

        /* Estados ativos para bot√µes de toggle de visualiza√ß√£o */
        .btn.active {
            background: #667eea !important;
            color: white !important;
            border-color: #667eea !important;
        }

        .mapping-actions {
            display: flex;
            gap: 8px;
        }

        .mapping-actions .btn {
            padding: 8px 12px;
            font-size: 0.85rem;
        }

        .mapping-view {
            transition: all 0.3s ease;
        }

        .mapping-view.active {
            display: block;
        }

        /* Vis√£o Detalhada de Mapeamentos - Layout Ultra Compacto */
        .detailed-mapping-item {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 6px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }

        .detailed-mapping-header {
            background: #667eea;
            color: white;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .detailed-mapping-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .detailed-mapping-stats {
            display: flex;
            gap: 12px;
            font-size: 0.85rem;
        }

        .detailed-mapping-body {
            padding: 16px;
        }

        .columns-comparison {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 16px;
            align-items: start;
        }

        .column-group {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            background: #f8f9fa;
        }

        .column-group h5 {
            margin-bottom: 10px;
            color: #333;
            font-weight: 600;
            padding-bottom: 6px;
            border-bottom: 2px solid #e0e0e0;
            font-size: 0.9rem;
        }

        .column-list-detailed {
            max-height: 250px;
            overflow-y: auto;
        }

        .column-item-detailed {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin: 4px 0;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
        }

        .column-item-detailed:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
        }

        .column-item-detailed.mapped {
            background: #d4edda;
            border-color: #28a745;
        }

        .column-item-detailed.mapped::after {
            content: "‚úì";
            position: absolute;
            top: 2px;
            right: 5px;
            color: #28a745;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .column-item-detailed.unmapped {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .column-item-detailed.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .column-name-detailed {
            font-weight: 500;
            color: #333;
            font-size: 0.85rem;
        }

        .column-type-detailed {
            font-size: 0.75rem;
            color: #666;
            background: #e9ecef;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .mapping-connector {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 12px 8px;
        }

        .mapping-arrow-detailed {
            background: #28a745;
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin: 5px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .mapping-arrow-detailed:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }

        /* Status de Transfer√™ncia */
        .transfer-status {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #28a745;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .transfer-status .status-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .transfer-status .status-header h4 {
            color: #28a745;
            margin: 0;
        }

        .transfer-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            text-align: center;
        }

        .summary-value {
            font-size: 2rem;
            font-weight: 700;
            color: #28a745;
            margin-bottom: 5px;
        }

        .summary-label {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .transfer-readiness {
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #dee2e6;
        }

        .readiness-check {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .readiness-check.success {
            background: #d4edda;
            color: #155724;
        }

        .readiness-check.warning {
            background: #fff3cd;
            color: #856404;
        }

        .readiness-check.error {
            background: #f8d7da;
            color: #721c24;
        }

        .readiness-icon {
            margin-right: 10px;
            font-size: 1.2rem;
        }

        /* Utilit√°rios para Layout Responsivo */
        .d-flex { display: flex; }
        .flex-wrap { flex-wrap: wrap; }
        .flex-nowrap { flex-wrap: nowrap; }
        .justify-start { justify-content: flex-start; }
        .justify-center { justify-content: center; }
        .justify-end { justify-content: flex-end; }
        .justify-between { justify-content: space-between; }
        .align-center { align-items: center; }
        .align-start { align-items: flex-start; }
        .gap-2 { gap: 2px; }
        .gap-4 { gap: 4px; }
        .gap-6 { gap: 6px; }
        .gap-8 { gap: 8px; }
        .gap-10 { gap: 10px; }
        .w-100 { width: 100%; }
        .w-auto { width: auto; }
        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-right { text-align: right; }
        .m-0 { margin: 0; }
        .m-2 { margin: 2px; }
        .m-4 { margin: 4px; }
        .p-0 { padding: 0; }
        .p-2 { padding: 2px; }
        .p-4 { padding: 4px; }
        .mb-0 { margin-bottom: 0; }
        .mb-2 { margin-bottom: 2px; }
        .mb-4 { margin-bottom: 4px; }
        .mb-8 { margin-bottom: 8px; }
        .mt-0 { margin-top: 0; }
        .mt-2 { margin-top: 2px; }
        .mt-4 { margin-top: 4px; }

        /* Estilos para aba de Migra√ß√£o */
        .validated-mappings-list {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            border: 1px solid #e9ecef;
        }

        .validated-mappings-list h4 {
            color: #495057;
            margin-bottom: 12px;
            font-size: 1.1rem;
            border-bottom: 2px solid #28a745;
            padding-bottom: 8px;
        }

        .migration-mapping-item {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }

        .migration-mapping-item:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }

        .migration-mapping-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .migration-mapping-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
            color: #495057;
        }

        .migration-mapping-stats {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .migration-mapping-details {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 16px;
            align-items: center;
            margin-top: 8px;
        }

        .mapping-summary {
            font-size: 0.85rem;
            color: #6c757d;
            line-height: 1.4;
        }

        .migration-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .migration-actions .btn {
            padding: 4px 8px;
            font-size: 0.75rem;
            min-width: 80px;
        }

        .migration-settings {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            border: 1px solid #e9ecef;
        }

        .migration-settings h4 {
            color: #495057;
            margin-bottom: 12px;
            font-size: 1.1rem;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .migration-actions-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #dee2e6;
            text-align: center;
        }

        /* Estilos para controles de sele√ß√£o m√∫ltipla */
        .migration-controls {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid #90caf9;
        }

        .migration-controls h4 {
            color: #1976d2;
            margin-bottom: 10px;
            font-size: 1rem;
            font-weight: 600;
        }

        .migration-controls .button-group {
            gap: 10px;
        }

        .migration-selection {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }

        .migration-checkbox {
            width: 18px;
            height: 18px;
            margin: 0;
            cursor: pointer;
            accent-color: #28a745;
        }

        .migration-mapping-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .migration-progress {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            border: 1px solid #dee2e6;
        }

        .migration-progress h4 {
            color: #495057;
            margin-bottom: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .migration-success {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 1px solid #28a745;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
        }

        .migration-success h4 {
            color: #155724;
            margin-bottom: 10px;
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            font-size: 0.75rem;
            font-weight: 600;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 12px;
        }

        .badge-success {
            color: white;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .badge-info {
            color: white;
            background: linear-gradient(135deg, #17a2b8 0%, #6f42c1 100%);
        }

        .columns-mapping-preview {
            margin-top: 12px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .column-mapping-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr auto;
            gap: 8px;
            align-items: center;
            padding: 4px 0;
            font-size: 0.85rem;
        }

        .source-col,
        .target-col {
            font-weight: 600;
            color: #495057;
        }

        .mapping-arrow {
            color: #667eea;
            font-weight: bold;
            text-align: center;
        }

        .type-info {
            font-size: 0.75rem;
            color: #6c757d;
            text-align: right;
        }

        @media (max-width: 768px) {
            .migration-mapping-details {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .migration-actions {
                justify-content: center;
            }
            
            .column-mapping-row {
                grid-template-columns: 1fr;
                gap: 4px;
                text-align: center;
            }
            
            .type-info {
                text-align: center;
            }
        }
        .mt-8 { margin-top: 8px; }

        /* Button Sizes - Varia√ß√µes Compactas */
        .btn-xs {
            padding: 3px 6px;
            font-size: 0.7rem;
            min-width: 50px;
            border-radius: 4px;
        }

        .btn-sm {
            padding: 4px 8px;
            font-size: 0.75rem;
            min-width: 60px;
            border-radius: 6px;
        }

        .btn-md {
            padding: 6px 12px;
            font-size: 0.8rem;
            min-width: 70px;
            border-radius: 8px;
        }

        .btn-lg {
            padding: 12px 24px;
            font-size: 1rem;
            min-width: 200px;
            border-radius: 10px;
            font-weight: 600;
        }

        /* Button Groups Especializados */
        .btn-group-horizontal {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }

        .btn-group-horizontal .btn:first-child {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .btn-group-horizontal .btn:last-child {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        .btn-group-horizontal .btn:not(:first-child):not(:last-child) {
            border-radius: 0;
        }

        .btn-group-vertical {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .btn-toolbar-responsive {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-start;
            align-items: center;
            margin: 8px 0;
        }

        /* Connection Tab - Bot√µes Compactos */
        .connection-card .button-group {
            margin-bottom: 6px;
        }

        .connection-card .button-group .btn {
            font-size: 0.75rem;
            padding: 5px 8px;
            min-width: 85px;
            margin: 1px;
        }

        @media (max-width: 576px) {
            .btn-toolbar-responsive {
                justify-content: center;
            }
            
            .btn-group-horizontal {
                flex-direction: column;
                width: 100%;
            }
            
            .btn-group-horizontal .btn {
                width: 100%;
                border-radius: 6px !important;
                margin: 1px 0;
            }

            /* Connection Tab - Mobile - apenas aqui empilha verticalmente */
            .connection-card .button-group {
                flex-direction: column;
                align-items: stretch;
                gap: 4px;
            }

            .connection-card .button-group .btn {
                width: 100%;
                min-width: unset;
                max-width: unset;
                font-size: 0.7rem;
                padding: 6px 8px;
                margin: 2px 0;
            }
        }

        /* Anima√ß√µes Melhoradas */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-up {
            animation: fadeInUp 0.3s ease-out;
        }

        .btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .card {
            animation: fadeInUp 0.3s ease-out;
        }

        /* Responsive Breakpoints Personalizados */
        @media (min-width: 769px) {
            /* Garantir que bot√µes fiquem horizontais em telas grandes */
            .connection-card .button-group {
                flex-direction: row !important;
                flex-wrap: wrap;
                justify-content: flex-start;
                gap: 6px;
            }

            .connection-card .button-group .btn {
                flex: 0 0 auto;
                min-width: 90px;
                max-width: 140px;
                font-size: 0.75rem;
                padding: 5px 8px;
                margin: 2px;
            }

            .action-group,
            .button-row {
                flex-direction: row !important;
                flex-wrap: wrap;
                justify-content: flex-start;
                gap: 6px;
            }

            .action-group .btn,
            .button-row .btn {
                flex: 0 0 auto;
                min-width: 90px;
                max-width: 140px;
            }

            /* Layout responsivo para dispositivos m√≥veis */
            .view-toggle {
                flex-direction: column;
                gap: 6px;
                width: 100%;
            }

            .view-toggle .btn {
                width: 100%;
                font-size: 0.8rem;
                padding: 8px 12px;
            }

            .mapping-actions {
                flex-direction: column;
                gap: 6px;
                width: 100%;
            }
            }

            .mapping-actions .btn {
                min-width: 120px;
                font-size: 0.85rem;
                padding: 8px 12px;
            }

            /* Layout do container principal em telas grandes */
            .container {
                max-width: 1800px;
                padding: 15px;
            }

            .tab-content {
                padding: 20px;
                min-height: 400px;
            }

            /* Mapping container otimizado para desktop */
            .mapping-container {
                min-height: 350px;
                gap: 12px;
            }

            .schema-panel {
                height: 350px;
                padding: 12px;
            }

            .schema-panel h3 {
                font-size: 1rem;
                padding: 6px;
            }

            /* Grid layouts otimizados para desktop */
            .grid-2 {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }

            .grid-3 {
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
            }

            .grid-4 {
                grid-template-columns: repeat(4, 1fr);
                gap: 12px;
            }

            /* Connection section em desktop */
            .connection-section {
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }

            .connection-card {
                padding: 15px;
            .mapping-actions .btn {
                width: 100%;
                font-size: 0.8rem;
                padding: 8px 12px;
            }

            .mapping-controls {
                flex-direction: column;
                gap: 12px;
                padding: 12px;
            }

            /* Stats grid otimizado para desktop */
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 12px;
            }
        }

        @media (min-width: 1400px) {
            /* Otimiza√ß√µes para telas muito grandes */
            .container {
                max-width: 1900px;
                padding: 20px;
            }

            .tab-content {
                padding: 25px;
                min-height: 450px;
            }

            /* Mapping container em telas grandes */
            .mapping-container {
                min-height: 400px;
                gap: 15px;
            }

            .schema-panel {
                height: 400px;
                padding: 15px;
            }

            /* Grid com mais colunas em telas grandes */
            .grid-3 {
                grid-template-columns: repeat(4, 1fr);
            }

            .grid-4 {
                grid-template-columns: repeat(5, 1fr);
            }

            /* Stats com grid maior */
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
            }

            /* Bot√µes maiores em telas grandes */
            .view-toggle .btn {
                min-width: 160px;
                max-width: 180px;
                font-size: 0.9rem;
                padding: 10px 15px;
            }

            .mapping-actions .btn {
                min-width: 140px;
                font-size: 0.9rem;
                padding: 10px 15px;
            }

            .connection-card .button-group .btn {
                min-width: 110px;
                max-width: 160px;
                font-size: 0.8rem;
                padding: 6px 10px;
            }
        }

        @media (max-width: 1400px) {
            .container {
                max-width: 100%;
                padding: 10px;
            }
        }

        @media (max-width: 992px) {
            .grid-3 {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .mapping-container {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }

        @media (max-width: 576px) {
            .grid-2, .grid-3, .grid-4 {
                grid-template-columns: 1fr;
            }
            
            .btn-group, .button-row, .action-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn-group .btn, .button-row .btn, .action-group .btn {
                width: 100%;
                margin: 2px 0;
            }
        }

        /* Convers√£o de Tipos - Layout Ultra Compacto */
        .type-conversion {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 6px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-size: 0.75rem;
            min-width: auto;
        }

        .type-conversion.compact {
            padding: 2px 4px;
            gap: 2px;
            font-size: 0.7rem;
        }

        .type-conversion .source-type {
            color: #495057;
            font-weight: 500;
        }

        .type-conversion .conversion-arrow {
            color: #667eea;
            font-weight: bold;
            margin: 0 2px;
        }

        .type-conversion .target-type {
            color: #28a745;
            font-weight: 600;
        }

        .type-display {
            padding: 2px 6px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 0.75rem;
            color: #495057;
            font-weight: 500;
        }

        .type-display.same-type {
            background: #d4edda;
            color: #155724;
        }

        .type-display.same-type {
            color: #28a745;
            font-weight: 600;
            background: #d4edda;
            padding: 4px 8px;
        }

        /* Convers√µes Espec√≠ficas por Tipo */
        .type-conversion[title*="TEXT_TO_DATE"] .conversion-arrow {
            color: #007bff;
        }

        .type-conversion[title*="TEXT_TO_NUMBER"] .conversion-arrow {
            color: #28a745;
        }

        .type-conversion[title*="NUMBER_TO_TEXT"] .conversion-arrow {
            color: #6610f2;
        }

        .type-conversion[title*="DATE_TO_TEXT"] .conversion-arrow {
            color: #fd7e14;
        }

        .type-conversion[title*="DIRECT"] .conversion-arrow {
            color: #20c997;
        }

        .type-conversion[title*="CUSTOM_CONVERSION"] .conversion-arrow {
            color: #ffc107;
        }

        /* Indicador visual para convers√µes */
        .requires-conversion {
            background: linear-gradient(45deg, #fff3cd 25%, transparent 25%, transparent 50%, #fff3cd 50%, #fff3cd 75%, transparent 75%, transparent);
            background-size: 8px 8px;
        }

        /* Melhorias na exibi√ß√£o de colunas */
        .column-item-detailed .column-type-detailed {
            margin-top: 5px;
        }

        .mapping-conversion-preview {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }

        .mapping-conversion-preview h6 {
            color: #1976d2;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .conversion-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .conversion-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e3f2fd;
        }

        .conversion-item .column-name {
            font-weight: 500;
            color: #1976d2;
        }

        /* Conex√µes de Mapeamento Visuais */
        .column-mapping-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #28a745, #20c997);
            z-index: 10;
            pointer-events: none;
            border-radius: 1px;
        }

        .column-mapping-line::after {
            content: "‚Üí";
            position: absolute;
            right: -15px;
            top: -8px;
            color: #20c997;
            font-size: 16px;
            font-weight: bold;
        }

        /* Modal de Detalhes do Mapeamento */
        .mapping-details-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .mapping-details-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 15px;
            padding: 30px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .mapping-summary {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            border-left: 4px solid #667eea;
        }

        .mapping-summary h6 {
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #495057;
            font-weight: 600;
        }

        .mapping-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin: 15px 0;
        }

        .stat-item {
            background: white;
            padding: 8px 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #dee2e6;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
        }

        .stat-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: bold;
            color: #667eea;
            line-height: 1.2;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.75rem;
            margin-top: 2px;
            font-weight: 500;
        }

        /* Layout compacto para estat√≠sticas em linha */
        .mapping-stats.compact {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
        }

        .mapping-stats.compact .stat-item {
            flex: 1;
            min-width: 90px;
            padding: 6px 8px;
        }

        .mapping-stats.compact .stat-value {
            font-size: 1rem;
        }

        .mapping-stats.compact .stat-label {
            font-size: 0.7rem;
        }

        /* Estilos adicionais para mapeamentos */
        .column-mappings-preview {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .column-mapping-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .column-mapping-item:last-child {
            border-bottom: none;
        }

        .column-source, .column-target {
            flex: 1;
            font-size: 1rem;
        }

        .column-source {
            color: #333;
            text-align: left;
        }

        .column-target {
            color: #333;
            text-align: right;
        }

        .column-arrow {
            margin: 0 16px;
            color: #667eea;
            font-weight: bold;
        }

        .column-mappings-detail {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 24px;
            margin: 24px 0;
        }

        .column-mapping-detail {
            display: grid;
            grid-template-columns: 2fr auto 2fr auto;
            align-items: center;
            gap: 16px;
            padding: 16px;
            background: white;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid #e0e0e0;
        }

        .source-detail, .target-detail {
            padding: 8px;
        }

        .arrow-detail {
            text-align: center;
            color: #667eea;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .compatibility {
            text-align: center;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .compatibility.compatible {
            background: #d4edda;
            color: #155724;
        }

        .compatibility.incompatible {
            background: #f8d7da;
            color: #721c24;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 0.875rem;
            margin: 0 4px;
        }

        /* Anima√ß√µes */
        @keyframes mappingSuccess {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .column-item.mapping-success {
            animation: mappingSuccess 0.5s ease;
        }

        /* Auto-suggestion */
        .suggestion-item {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            position: relative;
        }

        .suggestion-item::before {
            content: "üí°";
            position: absolute;
            top: 10px;
            right: 15px;
        }

        .auto-detect-btn {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Loading Overlay para an√°lise de esquemas */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }

        .loading-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            min-width: 300px;
            animation: loadingPulse 0.5s ease-out;
        }

        @keyframes loadingPulse {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid #f3f3f3;
            border-top: 6px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .loading-title {
            font-size: 1.4rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .loading-message {
            font-size: 1rem;
            color: #666;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .loading-progress {
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .loading-progress-bar {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
            animation: progressGlow 2s ease-in-out infinite alternate;
        }

        @keyframes progressGlow {
            from { box-shadow: 0 0 5px rgba(102, 126, 234, 0.3); }
            to { box-shadow: 0 0 15px rgba(102, 126, 234, 0.6); }
        }

        .loading-steps {
            text-align: left;
            margin-top: 20px;
        }

        .loading-step {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #666;
        }

        .loading-step.active {
            color: #667eea;
            font-weight: 600;
        }

        .loading-step.completed {
            color: #28a745;
        }

        .loading-step-icon {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Navigation Bar -->
        <div class="nav-bar">
            <div class="nav-brand">
                <span>üéØ</span>
                <span>Perito Legado</span>
            </div>
            <div class="nav-links">
                <a href="/" class="nav-link active">
                    <span>üöÄ</span>
                    <span>Migra√ß√£o Inteligente</span>
                </a>
                <a href="/validation-panel.html" class="nav-link">
                    <span>üß™</span>
                    <span>Valida√ß√µes</span>
                </a>
                <a href="/dashboard.html" class="nav-link">
                    <span>üìä</span>
                    <span>Dashboard</span>
                </a>
            </div>
        </div>

    <div class="header">
        <h1>üéØ Sistema de Migra√ß√£o Inteligente</h1>
        <p>Mapeamento Inteligente de Dados ‚Ä¢ Paradox/SQLite ‚Üí Firebird</p>
    </div>        <div class="main-panel">
            <div class="tabs">
                <div class="tab active" data-tab="connection">
                    üîå Conex√µes
                </div>
                <div class="tab" data-tab="mapping">
                    üéØ Mapeamento Inteligente
                </div>
                <div class="tab" data-tab="migration">
                    üöÄ Migra√ß√£o
                </div>
                <div class="tab" data-tab="monitoring">
                    üìä Monitoramento
                </div>
            </div>

            <!-- Connection Tab -->
            <div class="tab-content active" id="connection">
                <div class="connection-section">
                    <div class="connection-card">
                        <h3>üìÅ Banco de Origem</h3>
                        
                        <div class="form-group">
                            <label>üéØ Tipo do Banco</label>
                            <select id="sourceType" onchange="updateSourceInterface()" onclick="console.log('üñ±Ô∏è Select clicado!')">
                                <option value="paradox">üìä Paradox (.db, .pdx, .px)</option>
                                <option value="sqlite">üóÉÔ∏è SQLite (.db, .sqlite, .sqlite3)</option>
                            </select>
                            <small class="form-text">
                                Selecione o tipo do banco de dados de origem
                            </small>
                        </div>
                        
                        <div class="form-group">
                            <label>Localiza√ß√£o do Banco</label>
                            <select id="sourceLocation">
                                <option value="local">üìÅ Arquivo Local</option>
                                <option value="network">üåê Rede</option>
                                <option value="onedrive">‚òÅÔ∏è OneDrive</option>
                                <option value="googledrive">üîó Google Drive</option>
                                <option value="dropbox">üì¶ Dropbox</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label>Caminho do Banco</label>
                            <div class="path-input-container">
                                <input type="text" id="sourcePath" placeholder="Clique em 'Procurar' para selecionar o arquivo..." readonly 
                                       onclick="console.log('üìÅ Input clicado!'); openNativeFileDialog('source')">
                                <button class="btn btn-secondary" onclick="openNativeFileDialog('source')" title="Procurar arquivo com seletor nativo">
                                    üìÅ Procurar
                                </button>
                                <button class="btn btn-secondary" onclick="openFileExplorer('source')" title="Navegador interno">
                                    üóÇÔ∏è Navegar
                                </button>
                            </div>
                        </div>

                        <div class="recent-files-section">
                            <label>üìÇ Bancos Recentes</label>
                            <div id="recentSourceFiles" class="recent-files-list">
                                <!-- Arquivos recentes ser√£o carregados aqui -->
                            </div>
                        </div>

                        <div class="form-group">
                            <div class="button-group d-flex flex-wrap justify-start gap-6">
                                <button class="btn btn-sm auto-detect-btn" onclick="autoDetectSource()">
                                    üîç Auto-detectar
                                </button>
                                <button class="btn btn-sm" onclick="testSourceConnection()">
                                    üß™ Testar Conex√£o
                                </button>
                                <button class="btn btn-sm btn-success" onclick="testSQLiteInterface()">
                                    üóÉÔ∏è Teste SQLite
                                </button>
                                <button class="btn btn-sm btn-danger" onclick="testFileDialog()">
                                    üîß Debug Dialog
                                </button>
                                <button class="btn btn-sm btn-purple" onclick="forceShowSQLite()">
                                    üîç For√ßar SQLite
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="connection-card">
                        <h3>üî• Banco de Destino (Firebird)</h3>
                        
                        <div class="form-group">
                            <label>Servidor</label>
                            <input type="text" id="targetHost" placeholder="localhost" value="localhost">
                        </div>

                        <div class="form-group">
                            <label>Porta</label>
                            <input type="number" id="targetPort" placeholder="3050" value="3050">
                        </div>

                        <div class="form-group">
                            <label>Caminho do Database</label>
                            <div class="path-input-container">
                                <input type="text" id="targetDatabase" placeholder="Clique em 'Procurar' para selecionar o arquivo Firebird...">
                                <button class="btn btn-secondary" onclick="openNativeFileDialog('target')" title="Procurar arquivo com seletor nativo">
                                    üìÅ Procurar
                                </button>
                                <button class="btn btn-secondary" onclick="openFileExplorer('target')" title="Navegador interno">
                                    üóÇÔ∏è Navegar
                                </button>
                            </div>
                        </div>

                        <div class="recent-files-section">
                            <label>üìÇ Bancos Firebird Recentes</label>
                            <div id="recentTargetFiles" class="recent-files-list">
                                <!-- Arquivos recentes ser√£o carregados aqui -->
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Usu√°rio</label>
                            <input type="text" id="targetUser" placeholder="SYSDBA" value="SYSDBA">
                        </div>

                        <div class="form-group">
                            <label>Senha</label>
                            <input type="password" id="targetPassword" placeholder="masterkey" value="masterkey">
                        </div>

                        <div class="form-group">
                            <label>Charset</label>
                            <select id="targetCharset">
                                <option value="WIN1252">WIN1252</option>
                                <option value="UTF8">UTF8</option>
                                <option value="ISO8859_1">ISO8859_1</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <div class="button-group d-flex justify-start">
                                <button class="btn btn-sm" onclick="testTargetConnection()">
                                    üß™ Testar Conex√£o
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="text-align: center;">
                    <button class="btn-success btn" onclick="analyzeSchemas()">
                        üîç Analisar Esquemas e Gerar Mapeamentos
                    </button>
                </div>
            </div>

            <!-- Mapping Tab -->
            <div class="tab-content" id="mapping">
                <!-- Status do Progresso de Mapeamento -->
                <div class="mapping-progress-section" id="mappingProgressSection">
                    <div class="progress-info">
                        <div class="progress-stats">
                            <span id="mappingStats">0 mapeamentos configurados</span>
                            <span id="validationStats">0 validados</span>
                        </div>
                        <div class="current-selection" id="currentSelection" style="display: none;">
                            <span>üéØ Sele√ß√µes atuais:</span>
                            <span id="selectionInfo"></span>
                        </div>
                    </div>
                </div>

                <div class="mapping-container">
                    <div class="schema-panel">
                        <h3 id="sourceTablesTitle">üìÅ Tabelas de Origem</h3>
                        <div class="search-container">
                            <input type="text" id="sourceTablesSearch" class="table-search" placeholder="üîç Pesquisar tabelas de origem..." onkeyup="filterTables('source', this.value)" oninput="toggleClearButton('source', this.value)">
                            <button class="clear-search" id="clearSourceSearch" onclick="clearTableSearch('source')" title="Limpar pesquisa">‚úï</button>
                        </div>
                        <div id="sourceTablesList" class="table-list">
                            <!-- Tabelas ser√£o carregadas dinamicamente -->
                        </div>
                    </div>

                    <div class="mapping-controls">
                        <div class="button-group">
                            <button class="btn btn-secondary" onclick="clearMappings()">
                                üóëÔ∏è Limpar
                            </button>
                        </div>

                        <!-- Advanced Mapping Controls -->
                        <div class="advanced-mapping-section">
                            <h4>üéØ Mapeamentos Avan√ßados</h4>
                            
                            <div class="button-group">
                                <button class="btn" onclick="createManyToOneMapping()" title="M√∫ltiplas tabelas para uma">
                                    üìä N:1
                                </button>
                                
                                <button class="btn" onclick="createOneToManyMapping()" title="Uma tabela para m√∫ltiplas">
                                    üîÄ 1:N
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="schema-panel">
                        <h3>üî• Tabelas de Destino (Firebird)</h3>
                        <div class="search-container">
                            <input type="text" id="targetTablesSearch" class="table-search" placeholder="üîç Pesquisar tabelas de destino..." onkeyup="filterTables('target', this.value)" oninput="toggleClearButton('target', this.value)">
                            <button class="clear-search" id="clearTargetSearch" onclick="clearTableSearch('target')" title="Limpar pesquisa">‚úï</button>
                        </div>
                        <div id="targetTablesList" class="table-list">
                            <!-- Tabelas ser√£o carregadas dinamicamente -->
                        </div>
                    </div>
                </div>

                <div class="mapping-list">
                    <h3>üîó Mapeamentos Configurados</h3>
                    
                    <!-- Controles de Visualiza√ß√£o -->
                    <div class="button-group">
                        <button class="btn btn-primary active" id="simpleViewBtn" onclick="toggleMappingView('simple')">
                            üìã Vis√£o Simples
                        </button>
                        <button class="btn btn-secondary" id="detailedViewBtn" onclick="toggleMappingView('detailed')">
                            üîç Vis√£o Detalhada
                        </button>
                    </div>

                    <!-- Lista de Mapeamentos Simples -->
                    <div id="simpleMappingView" class="mapping-view active">
                        <div id="mappingsList">
                            <!-- Mapeamentos ser√£o exibidos aqui -->
                        </div>
                    </div>

                    <!-- Vis√£o Detalhada com Colunas -->
                    <div id="detailedMappingView" class="mapping-view" style="display: none;">
                        <div id="detailedMappingsList">
                            <!-- Mapeamentos detalhados ser√£o exibidos aqui -->
                        </div>
                    </div>

                    <!-- Status de Transfer√™ncia -->
                    <div class="transfer-status" id="transferStatus" style="display: none;">
                        <div class="status-header">
                            <h4>üöÄ Status da Configura√ß√£o de Transfer√™ncia</h4>
                        </div>
                        <div class="status-content">
                            <div class="transfer-summary" id="transferSummary">
                                <!-- Resumo ser√° preenchido dinamicamente -->
                            </div>
                            <div class="transfer-readiness" id="transferReadiness">
                                <!-- Status de prontid√£o ser√° preenchido dinamicamente -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Interface de Mapeamento Detalhado de Colunas -->
                <div class="column-mapping-interface" id="columnMappingInterface" style="display: none;">
                    <div class="mapping-header">
                        <h3>üîó Mapeamento Detalhado de Colunas</h3>
                        <div class="mapping-info">
                            <span id="currentMappingInfo">Selecione um mapeamento para editar</span>
                            <button class="btn btn-secondary" onclick="closeColumnMapping()">Fechar</button>
                        </div>
                    </div>

                    <div class="columns-container">
                        <!-- Colunas de Origem -->
                        <div class="column-list">
                            <h4>üì§ Colunas de Origem</h4>
                            <div id="sourceColumnsList">
                                <!-- Colunas de origem -->
                            </div>
                        </div>

                        <!-- Controles de Mapeamento -->
                        <div class="mapping-arrow-container">
                            <button class="mapping-arrow" onclick="autoMapColumns()" title="Auto-mapear colunas">
                                ü§ñ
                            </button>
                            <button class="mapping-arrow" onclick="clearColumnMappings()" title="Limpar mapeamentos">
                                üóëÔ∏è
                            </button>
                            <button class="mapping-arrow" onclick="showMappingDetails()" title="Ver detalhes">
                                üìã
                            </button>
                        </div>

                        <!-- Colunas de Destino -->
                        <div class="column-list">
                            <h4>üì• Colunas de Destino</h4>
                            <div id="targetColumnsList">
                                <!-- Colunas de destino -->
                            </div>
                        </div>
                    </div>

                    <!-- Resumo do Mapeamento -->
                    <div class="mapping-summary">
                        <h4>üìä Resumo do Mapeamento</h4>
                        <div class="mapping-stats compact">
                            <div class="stat-item">
                                <div class="stat-value" id="mappedColumnsCount">0</div>
                                <div class="stat-label">Mapeadas</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="unmappedSourceCount">0</div>
                                <div class="stat-label">Origem Pendente</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="unmappedTargetCount">0</div>
                                <div class="stat-label">Destino Livre</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="mappingCompleteness">0%</div>
                                <div class="stat-label">Progresso</div>
                            </div>
                        </div>
                    </div>

                    <div class="button-group">
                        <button class="btn btn-primary" onclick="saveMappingChanges()">üíæ Salvar Mapeamento</button>
                        <button class="btn btn-secondary" onclick="resetMapping()">üîÑ Resetar</button>
                        <button class="btn btn-success" onclick="validateMapping()">‚úÖ Validar Mapeamento</button>
                    </div>
                </div>
            </div>

            <!-- Migration Tab -->
            <div class="tab-content" id="migration">
                <div style="text-align: center; padding: 40px;">
                    <h2>üöÄ Executar Migra√ß√£o</h2>
                    <p style="margin: 20px 0; color: #6c757d;">Configure os mapeamentos antes de iniciar a migra√ß√£o</p>
                    
                    <!-- Debug Controls -->
                    <div style="margin: 20px 0; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
                        <p><strong>üîç Debug da Migra√ß√£o:</strong></p>
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn btn-info btn-sm" onclick="debugMigrationState()">
                                üîç Verificar Estado
                            </button>
                            <button class="btn btn-warning btn-sm" onclick="forceUpdateMigrationTab()">
                                üîÑ For√ßar Atualiza√ß√£o
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="console.log('validatedMappings:', validatedMappings)">
                                üìä Log Array
                            </button>
                        </div>
                    </div>
                    
                    <div style="margin: 30px 0;">
                        <div class="form-group" style="max-width: 300px; margin: 0 auto;">
                            <label>Tamanho do Lote</label>
                            <input type="number" id="batchSize" value="1000" min="100" max="10000">
                        </div>
                    </div>

                    <button class="btn btn-success btn-lg" onclick="startMigration()">
                        üöÄ Iniciar Migra√ß√£o Inteligente
                    </button>
                </div>
            </div>

            <!-- Monitoring Tab -->
            <div class="tab-content" id="monitoring">
                <div style="text-align: center; padding: 40px;">
                    <h2>üìä Monitoramento em Tempo Real</h2>
                    <div id="migrationStatus">
                        <!-- Status ser√° atualizado dinamicamente -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Panel -->
    <div class="status-panel" id="statusPanel" style="display: none;">
        <div class="status-header">
            <span class="status-title">Status da Conex√£o</span>
            <div class="status-indicator"></div>
        </div>
        <div id="statusContent">
            Sistema pronto para uso
        </div>
    </div>

    <!-- Modal de Detalhes do Mapeamento -->
    <div class="mapping-details-modal" id="mappingDetailsModal">
        <div class="mapping-details-content">
            <div class="modal-header">
                <h3>üìã Detalhes do Mapeamento</h3>
                <button class="btn btn-secondary" onclick="closeMappingDetailsModal()">‚úñÔ∏è Fechar</button>
            </div>
            
            <div id="mappingDetailsContent">
                <!-- Conte√∫do ser√° preenchido dinamicamente -->
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Conectar ao WebSocket
        const socket = io();
        
        // Estado da aplica√ß√£o
        let sourceSchema = [];
        let targetSchema = [];
        let selectedSourceTable = null;
        let selectedTargetTable = null;
        let tableMappings = [];
        
        // Mapeamentos validados e prontos para migra√ß√£o
        let validatedMappings = [];
        
        // Estado do mapeamento de colunas
        let currentMapping = null;
        let sourceColumns = [];
        let targetColumns = [];
        let columnMappings = [];
        let draggedColumn = null;

        // Inicializa√ß√£o
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Inicializando sistema...');
            
            // Debug: verificar se elementos existem
            const sourceTypeElement = document.getElementById('sourceType');
            console.log('sourceType element:', sourceTypeElement);
            if (sourceTypeElement) {
                console.log('sourceType options:', sourceTypeElement.children.length);
                for (let i = 0; i < sourceTypeElement.children.length; i++) {
                    console.log(`Option ${i}:`, sourceTypeElement.children[i].value, sourceTypeElement.children[i].textContent);
                }
            }
            
            initializeTabs();
            initializeDragAndDrop();
            setupSocketListeners();
            loadRecentFiles();
            updateSourceInterface(); // Inicializar interface baseada no tipo selecionado
            updateMigrationTab(); // Inicializar aba de migra√ß√£o
            
            console.log('‚úÖ Sistema inicializado!');
        });

        // Configura√ß√£o das abas
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.getAttribute('data-tab');
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(targetTab).classList.add('active');
                    
                    // Atualizar conte√∫do espec√≠fico da aba quando necess√°rio
                    if (targetTab === 'migration') {
                        console.log('üîÑ Mudan√ßa para aba de migra√ß√£o - atualizando conte√∫do...');
                        updateMigrationTab();
                        console.log('üìä Mapeamentos validados dispon√≠veis:', validatedMappings.length);
                    }
                });
            });
        }

        // Configura√ß√£o de drag and drop
        function initializeDragAndDrop() {
            // Ser√° implementado quando as tabelas forem carregadas
        }

        // Listeners do WebSocket
        function setupSocketListeners() {
            socket.on('connection-status', (data) => {
                showStatus(`Conex√£o: ${data.type} - ${data.status}`, data.success ? 'success' : 'error');
            });

            socket.on('schema-analysis', (data) => {
                if (data.type === 'source') {
                    sourceSchema = data.tables;
                    renderSourceTables();
                } else if (data.type === 'target') {
                    targetSchema = data.tables;
                    renderTargetTables();
                }
            });

            socket.on('mapping-suggestion', (data) => {
                renderMappingSuggestions(data.suggestions);
            });

            socket.on('migration-progress', (data) => {
                updateMigrationProgress(data);
            });
        }

        // Auto-detectar banco de origem
        async function autoDetectSource() {
            const sourceTypeElement = document.getElementById('sourceType');
            if (!sourceTypeElement) {
                showStatus('‚ùå Erro: Tipo de banco n√£o selecionado', 'error');
                return;
            }
            
            const sourceType = sourceTypeElement.value;
            const typeLabel = getTypeLabelForDisplay(sourceType);
            
            showStatus(`üîç Buscando bancos ${typeLabel} no sistema...`, 'info');
            
            try {
                // Definir extens√µes e caminhos baseados no tipo de banco
                const searchConfig = getSearchConfigForType(sourceType);
                
                const response = await fetch('/api/auto-detect-enhanced', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        type: 'source',
                        sourceType: sourceType,
                        extensions: searchConfig.extensions,
                        searchPaths: searchConfig.paths
                    })
                });

                const result = await response.json();
                
                if (result.success && result.databases && result.databases.length > 0) {
                    showStatus(`‚úÖ Encontrados ${result.databases.length} banco(s) ${typeLabel}`, 'success');
                    showDatabaseSelectionDialog('source', result.databases, sourceType);
                } else {
                    showStatus(`‚ùå Nenhum banco ${typeLabel} encontrado automaticamente`, 'warning');
                    // Oferecer busca manual
                    if (confirm(`N√£o foram encontrados bancos ${typeLabel} automaticamente.\nDeseja fazer uma busca manual?`)) {
                        openNativeFileDialog('source');
                    }
                }
            } catch (error) {
                console.error('Erro na auto-detec√ß√£o:', error);
                showStatus(`‚ùå Erro na busca: ${error.message}`, 'error');
                // Fallback para sele√ß√£o manual
                if (confirm('Erro na detec√ß√£o autom√°tica.\nDeseja selecionar manualmente?')) {
                    openNativeFileDialog('source');
                }
            }
        }

        // Fun√ß√£o auxiliar para configura√ß√£o de busca por tipo
        function getSearchConfigForType(sourceType) {
            switch (sourceType) {
                case 'sqlite':
                    return {
                        extensions: ['.db', '.sqlite', '.sqlite3'],
                        paths: [
                            'C:\\dados',
                            'C:\\sistema',
                            'C:\\Users\\' + (window.navigator.userAgent.includes('Windows') ? 'Public' : '') + '\\Documents',
                            'C:\\ProgramData',
                            'D:\\',
                            'E:\\'
                        ]
                    };
                case 'paradox':
                    return {
                        extensions: ['.db', '.pdx', '.px'],
                        paths: [
                            'C:\\dados',
                            'C:\\sistema',
                            'C:\\Program Files',
                            'C:\\Program Files (x86)',
                            'C:\\Users\\' + (window.navigator.userAgent.includes('Windows') ? 'Public' : '') + '\\Documents',
                            'D:\\',
                            'E:\\'
                        ]
                    };
                default:
                    return {
                        extensions: ['.db', '.sqlite', '.sqlite3', '.pdx', '.px'],
                        paths: [
                            'C:\\dados',
                            'C:\\sistema',
                            'C:\\Program Files',
                            'C:\\Users\\' + (window.navigator.userAgent.includes('Windows') ? 'Public' : '') + '\\Documents',
                            'D:\\',
                            'E:\\'
                        ]
                    };
            }
        }

        // Fun√ß√£o auxiliar para obter label do tipo
        function getTypeLabelForDisplay(sourceType) {
            switch (sourceType) {
                case 'sqlite': return 'SQLite';
                case 'paradox': return 'Paradox';
                default: return 'Banco';
            }
        }

        // Testar conex√£o de origem
        async function testSourceConnection() {
            const sourceTypeElement = document.getElementById('sourceType');
            const pathElement = document.getElementById('sourcePath');
            
            if (!sourceTypeElement || !pathElement) {
                showStatus('‚ùå Erro: Elementos da interface n√£o encontrados', 'error');
                return;
            }
            
            const sourceType = sourceTypeElement.value;
            const path = pathElement.value.trim();
            
            if (!path) {
                showStatus('‚ùå Informe o caminho do banco', 'error');
                pathElement.focus();
                return;
            }

            const typeLabel = getTypeLabelForDisplay(sourceType);
            showStatus(`üß™ Testando conex√£o ${typeLabel}...`, 'info');

            try {
                // Configurar conex√£o baseada no tipo
                const config = buildConnectionConfig(sourceType, path);
                
                const response = await fetch('/api/test-connection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        type: sourceType,
                        config: config
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    const tableCount = result.schema?.tables?.length || 0;
                    const columnCount = result.schema?.totalColumns || 0;
                    
                    let message = `‚úÖ Conex√£o ${typeLabel} estabelecida com sucesso`;
                    if (tableCount > 0) {
                        message += `\nüìä ${tableCount} tabela(s) encontrada(s)`;
                        if (columnCount > 0) {
                            message += ` com ${columnCount} coluna(s) total`;
                        }
                    }
                    
                    showStatus(message, 'success');
                    
                    // Atualizar UI com informa√ß√µes do schema se dispon√≠vel
                    if (result.schema && result.schema.tables) {
                        console.log('üìä Schema detectado:', result.schema);
                        // Armazenar para uso posterior
                        window.lastSourceSchema = result.schema;
                    }
                } else {
                    const errorMsg = result.error || 'Erro desconhecido';
                    showStatus(`‚ùå Erro na conex√£o ${typeLabel}: ${errorMsg}`, 'error');
                    
                    // Sugerir verifica√ß√µes comuns
                    if (errorMsg.includes('arquivo n√£o encontrado') || errorMsg.includes('not found')) {
                        showStatus('üí° Verifique se o caminho do arquivo est√° correto', 'warning');
                    } else if (errorMsg.includes('permiss√£o') || errorMsg.includes('permission')) {
                        showStatus('üí° Verifique as permiss√µes de acesso ao arquivo', 'warning');
                    } else if (errorMsg.includes('formato') || errorMsg.includes('format')) {
                        showStatus('üí° Verifique se o arquivo est√° no formato correto', 'warning');
                    }
                }
            } catch (error) {
                console.error('Erro na conex√£o:', error);
                showStatus(`‚ùå Erro na conex√£o: ${error.message}`, 'error');
            }
        }

        // Fun√ß√£o auxiliar para construir configura√ß√£o de conex√£o
        function buildConnectionConfig(sourceType, path) {
            switch (sourceType) {
                case 'sqlite':
                    return {
                        database: path,
                        path: path,
                        mode: 'readonly',
                        timeout: 10000
                    };
                case 'paradox':
                    return {
                        path: path,
                        directory: path.substring(0, path.lastIndexOf('\\')),
                        readonly: true
                    };
                default:
                    return { path: path };
            }
        }

        // Testar conex√£o de destino
        async function testTargetConnection() {
            const config = {
                host: document.getElementById('targetHost').value,
                port: parseInt(document.getElementById('targetPort').value),
                database: document.getElementById('targetDatabase').value,
                user: document.getElementById('targetUser').value,
                password: document.getElementById('targetPassword').value,
                charset: document.getElementById('targetCharset').value
            };

            showStatus('üß™ Testando conex√£o Firebird...', 'info');

            try {
                const response = await fetch('/api/test-target-connection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        type: 'firebird',
                        config: config 
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    showStatus('‚úÖ Conex√£o Firebird estabelecida', 'success');
                } else {
                    showStatus(`‚ùå Erro na conex√£o: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Erro na conex√£o: ${error.message}`, 'error');
            }
        }

        // Analisar esquemas com loading overlay
        async function analyzeSchemas() {
            // Validar configura√ß√µes antes de iniciar
            const sourceTypeElement = document.getElementById('sourceType');
            const sourcePathElement = document.getElementById('sourcePath');
            const targetDatabaseElement = document.getElementById('targetDatabase');
            
            if (!sourceTypeElement || !sourcePathElement || !targetDatabaseElement) {
                showStatus('‚ùå Erro: Elementos da interface n√£o encontrados', 'error');
                return;
            }
            
            const sourcePath = sourcePathElement.value.trim();
            const targetDatabase = targetDatabaseElement.value.trim();
            
            if (!sourcePath) {
                showStatus('‚ùå Informe o caminho do banco de origem', 'error');
                sourcePathElement.focus();
                return;
            }
            
            if (!targetDatabase) {
                showStatus('‚ùå Informe o caminho do banco de destino', 'error');
                targetDatabaseElement.focus();
                return;
            }
            
            // Criar e mostrar overlay de loading
            const loadingOverlay = createLoadingOverlay();
            document.body.appendChild(loadingOverlay);
            
            try {
                // Configura√ß√µes das conex√µes
                const sourceType = sourceTypeElement.value;
                const sourceConfig = {
                    type: sourceType,
                    path: sourcePath
                };

                const targetConfig = {
                    host: document.getElementById('targetHost').value || 'localhost',
                    port: parseInt(document.getElementById('targetPort').value) || 3050,
                    database: targetDatabase,
                    user: document.getElementById('targetUser').value || 'SYSDBA',
                    password: document.getElementById('targetPassword').value || 'masterkey',
                    charset: document.getElementById('targetCharset').value || 'UTF8'
                };

                // Atualizar progresso: Conectando ao banco de origem
                updateLoadingProgress(loadingOverlay, 1, 'Conectando ao banco de origem...');
                await sleep(800);

                // Atualizar progresso: Conectando ao banco de destino  
                updateLoadingProgress(loadingOverlay, 2, 'Conectando ao banco de destino...');
                await sleep(800);

                // Atualizar progresso: Analisando estruturas
                updateLoadingProgress(loadingOverlay, 3, 'Analisando estruturas dos bancos...');
                await sleep(500);

                const response = await fetch('/api/analyze-schemas', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        source: sourceConfig, 
                        target: targetConfig 
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    // Atualizar progresso: Processando resultados
                    updateLoadingProgress(loadingOverlay, 4, 'Processando resultados...');
                    await sleep(500);
                    
                    // Armazenar esquemas nas vari√°veis globais
                    sourceSchema = result.sourceSchema?.tables || [];
                    targetSchema = result.targetSchema?.tables || [];
                    
                    // Armazenar tipo detectado
                    const detectedType = result.sourceType || sourceType;
                    
                    console.log('üìä An√°lise completa:', {
                        tipo: detectedType.toUpperCase(),
                        origem: sourceSchema.length + ' tabelas',
                        destino: targetSchema.length + ' tabelas'
                    });
                    
                    // Atualizar progresso: Gerando interface
                    updateLoadingProgress(loadingOverlay, 5, 'Gerando interface de mapeamento...');
                    await sleep(500);
                    
                    // Atualizar interface com tipo detectado
                    forceUpdateSourceTitle(detectedType);
                    updateInterfaceWithDetectedType(detectedType);
                    
                    // Renderizar as tabelas
                    renderSourceTables();
                    renderTargetTables();
                    
                    // Finalizar loading
                    updateLoadingProgress(loadingOverlay, 6, 'Conclu√≠do! Redirecionando...');
                    await sleep(800);
                    
                    // Remover overlay
                    document.body.removeChild(loadingOverlay);
                    
                    // Mostrar resultado final
                    const sourceCount = sourceSchema.length;
                    const targetCount = targetSchema.length;
                    showStatus(`‚úÖ An√°lise conclu√≠da: ${sourceCount} tabela(s) de origem, ${targetCount} tabela(s) de destino`, 'success');
                    
                    // Mudar para aba de mapeamento
                    setTimeout(() => {
                        const mappingTab = document.querySelector('[data-tab="mapping"]');
                        if (mappingTab) {
                            mappingTab.click();
                        } else {
                            // Fallback: ativar aba de mapeamento manualmente
                            showTab('mapping');
                        }
                    }, 500);
                    
                } else {
                    // Remover overlay em caso de erro
                    document.body.removeChild(loadingOverlay);
                    const errorMsg = result.error || 'Erro desconhecido na an√°lise';
                    showStatus(`‚ùå Erro na an√°lise: ${errorMsg}`, 'error');
                }
                
            } catch (error) {
                // Remover overlay em caso de erro
                if (document.body.contains(loadingOverlay)) {
                    document.body.removeChild(loadingOverlay);
                }
                
                console.error('Erro na an√°lise de esquemas:', error);
                showStatus(`‚ùå Erro na an√°lise: ${error.message}`, 'error');
            }
        }

        // Fun√ß√£o para criar overlay de loading
        function createLoadingOverlay() {
            const overlay = document.createElement('div');
            overlay.className = 'loading-overlay';
            
            overlay.innerHTML = `
                <div class="loading-content">
                    <div class="loading-spinner"></div>
                    <div class="loading-title">üîç Analisando Esquemas</div>
                    <div class="loading-message">Conectando aos bancos e analisando estruturas...</div>
                    
                    <div class="loading-progress">
                        <div class="loading-progress-bar" style="width: 0%"></div>
                    </div>
                    
                    <div class="loading-steps">
                        <div class="loading-step active" data-step="1">
                            <span class="loading-step-icon">üîó</span>
                            <span>Conectando ao banco de origem</span>
                        </div>
                        <div class="loading-step" data-step="2">
                            <span class="loading-step-icon">üéØ</span>
                            <span>Conectando ao banco de destino</span>
                        </div>
                        <div class="loading-step" data-step="3">
                            <span class="loading-step-icon">üìä</span>
                            <span>Analisando estruturas</span>
                        </div>
                        <div class="loading-step" data-step="4">
                            <span class="loading-step-icon">‚öôÔ∏è</span>
                            <span>Processando resultados</span>
                        </div>
                        <div class="loading-step" data-step="5">
                            <span class="loading-step-icon">üé®</span>
                            <span>Gerando interface</span>
                        </div>
                        <div class="loading-step" data-step="6">
                            <span class="loading-step-icon">‚úÖ</span>
                            <span>Finalizando</span>
                        </div>
                    </div>
                </div>
            `;
            
            return overlay;
        }

        // Fun√ß√£o para atualizar progresso do loading
        function updateLoadingProgress(overlay, step, message) {
            const progressBar = overlay.querySelector('.loading-progress-bar');
            const messageElement = overlay.querySelector('.loading-message');
            const steps = overlay.querySelectorAll('.loading-step');
            
            // Atualizar barra de progresso
            const percentage = (step / 6) * 100;
            progressBar.style.width = percentage + '%';
            
            // Atualizar mensagem
            messageElement.textContent = message;
            
            // Atualizar passos
            steps.forEach((stepElement, index) => {
                stepElement.classList.remove('active');
                if (index < step) {
                    stepElement.classList.add('completed');
                    stepElement.querySelector('.loading-step-icon').textContent = '‚úÖ';
                } else if (index === step - 1) {
                    stepElement.classList.add('active');
                } else {
                    stepElement.classList.remove('completed');
                }
            });
        }

        // Fun√ß√£o auxiliar para sleep
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // For√ßar atualiza√ß√£o do t√≠tulo das tabelas de origem
        function forceUpdateSourceTitle(detectedType) {
            console.log(`üîÑ FOR√áANDO atualiza√ß√£o do t√≠tulo para: ${detectedType}`);
            console.log('üîç DOM atual ao buscar elemento:');
            
            // Primeiro, tentar usar o ID espec√≠fico que acabamos de adicionar
            let targetTitle = document.getElementById('sourceTablesTitle');
            console.log('  - Resultado getElementById:', targetTitle);
            console.log('  - Texto atual do elemento:', targetTitle ? targetTitle.textContent : 'N/A');
            
            if (!targetTitle) {
                console.log('‚ùå Elemento n√£o encontrado pelo ID, usando fallback...');
                // Fallback: Encontrar TODOS os h3 e procurar o que cont√©m informa√ß√µes sobre origem
                const allH3s = document.querySelectorAll('h3');
                
                console.log(`üìã Encontrados ${allH3s.length} elementos h3:`);
                allH3s.forEach((h3, index) => {
                    console.log(`  ${index + 1}. "${h3.textContent}"`);
                    const text = h3.textContent.toLowerCase();
                    if (text.includes('origem') || text.includes('tabelas') || text.includes('paradox') || text.includes('sqlite')) {
                        targetTitle = h3;
                        console.log(`  ‚úÖ ALVO ENCONTRADO: "${h3.textContent}"`);
                    }
                });
            } else {
                console.log(`‚úÖ T√≠tulo encontrado pelo ID: "${targetTitle.textContent}"`);
            }
            
            if (!targetTitle) {
                // Se n√£o encontrou, procurar o cont√™iner das tabelas e adicionar um t√≠tulo
                const sourceContainer = document.getElementById('sourceTablesList');
                if (sourceContainer) {
                    console.log('üì¶ Cont√™iner sourceTablesList encontrado, criando t√≠tulo...');
                    targetTitle = document.createElement('h3');
                    targetTitle.id = 'sourceTablesTitle';
                    targetTitle.style.cssText = 'margin: 15px 0 10px 0; color: #495057; font-size: 1.2rem; font-weight: 600;';
                    
                    // Inserir antes do cont√™iner
                    if (sourceContainer.parentNode) {
                        sourceContainer.parentNode.insertBefore(targetTitle, sourceContainer);
                        console.log('‚úÖ T√≠tulo criado e inserido');
                    }
                }
            }
            
            if (targetTitle) {
                const typeName = detectedType === 'sqlite' ? 'SQLite' : 'Paradox';
                const icon = detectedType === 'sqlite' ? 'üóÉÔ∏è' : 'üìä';
                const newTitle = `${icon} Tabelas de Origem (${typeName})`;
                
                console.log(`üìù ALTERANDO T√çTULO:`);
                console.log(`  - Texto anterior: "${targetTitle.textContent}"`);
                console.log(`  - Texto novo: "${newTitle}"`);
                
                targetTitle.textContent = newTitle;
                targetTitle.style.color = '#495057';
                targetTitle.style.fontWeight = '600';
                
                console.log(`‚úÖ T√çTULO FOR√áADO PARA: "${newTitle}"`);
                console.log(`üìã Verifica√ß√£o final: "${targetTitle.textContent}"`);
                
                // Adicionar indicador visual extra
                targetTitle.setAttribute('data-db-type', detectedType);
                targetTitle.style.borderLeft = detectedType === 'sqlite' ? '4px solid #17a2b8' : '4px solid #28a745';
                targetTitle.style.paddingLeft = '10px';
                
                return true;
            } else {
                console.error('‚ùå FALHA: N√£o foi poss√≠vel encontrar ou criar o t√≠tulo');
                return false;
            }
        }

        // Atualizar interface com tipo detectado
        function updateInterfaceWithDetectedType(detectedType) {
            console.log(`üîÑ updateInterfaceWithDetectedType - Atualizando interface para tipo: ${detectedType}`);
            
            // Primeiro, tentar usar o ID espec√≠fico
            let sourceTablesTitle = document.getElementById('sourceTablesTitle');
            console.log('  - Elemento pelo ID:', sourceTablesTitle);
            console.log('  - Texto atual:', sourceTablesTitle ? sourceTablesTitle.textContent : 'N/A');
            
            // Se n√£o encontrou pelo ID, usar o m√©todo antigo
            if (!sourceTablesTitle) {
                console.log('‚ùå Elemento n√£o encontrado pelo ID, usando m√©todo antigo...');
                const elements = document.querySelectorAll('h3');
                sourceTablesTitle = Array.from(elements).find(el => 
                    el.textContent.includes('Tabelas de Origem') || 
                    el.textContent.includes('Origem')
                );
                console.log('  - Elemento pelo m√©todo antigo:', sourceTablesTitle);
            }
            
            if (sourceTablesTitle) {
                const typeName = detectedType === 'sqlite' ? 'SQLite' : 'Paradox';
                const icon = detectedType === 'sqlite' ? 'üóÉÔ∏è' : 'üìä';
                const newTitle = `${icon} Tabelas de Origem (${typeName})`;
                
                console.log(`üìù updateInterfaceWithDetectedType - ALTERANDO:`);
                console.log(`  - Texto anterior: "${sourceTablesTitle.textContent}"`);
                console.log(`  - Texto novo: "${newTitle}"`);
                
                sourceTablesTitle.textContent = newTitle;
                console.log(`‚úÖ T√≠tulo atualizado para: ${sourceTablesTitle.textContent}`);
            } else {
                console.warn('‚ö†Ô∏è T√≠tulo das tabelas de origem n√£o encontrado');
            }
            
            // Atualizar se√ß√£o de status para mostrar tipo detectado
            const statusSection = document.querySelector('.status-section') || document.querySelector('.connection-status');
            if (statusSection) {
                let typeIndicator = statusSection.querySelector('.detected-type');
                if (!typeIndicator) {
                    typeIndicator = document.createElement('div');
                    typeIndicator.className = 'detected-type';
                    typeIndicator.style.cssText = 'margin-top: 10px; padding: 8px; background: #e8f5e8; border-left: 4px solid #28a745; font-size: 0.9rem;';
                    statusSection.appendChild(typeIndicator);
                }
                
                const typeName = detectedType === 'sqlite' ? 'SQLite' : 'Paradox';
                const icon = detectedType === 'sqlite' ? 'üóÉÔ∏è' : 'üìä';
                typeIndicator.innerHTML = `${icon} <strong>Tipo Detectado:</strong> ${typeName}`;
            }
            
            // Atualizar bot√£o de transforma√ß√µes
            const transformBtn = document.querySelector('[onclick="showParadoxTransformations()"]');
            if (transformBtn) {
                const sourceName = detectedType === 'sqlite' ? 'SQLite' : 'Paradox';
                const icon = detectedType === 'sqlite' ? 'üóÉÔ∏è' : '‚ö°';
                transformBtn.innerHTML = `${icon} ${sourceName}‚ÜíFirebird`;
                transformBtn.title = `Transforma√ß√µes espec√≠ficas do ${sourceName}`;
            }
            
            // Atualizar select de tipo (se necess√°rio e existir)
            const sourceTypeSelect = document.getElementById('sourceType');
            if (sourceTypeSelect && sourceTypeSelect.value !== detectedType) {
                console.log(`üîÑ Atualizando select de ${sourceTypeSelect.value} para ${detectedType}`);
                sourceTypeSelect.value = detectedType;
                // Disparar evento de mudan√ßa para atualizar interface
                sourceTypeSelect.dispatchEvent(new Event('change'));
            }
            
            // For√ßar re-renderiza√ß√£o das tabelas se necess√°rio
            console.log(`üîÑ For√ßando re-renderiza√ß√£o das tabelas para ${detectedType}`);
            if (sourceSchema && sourceSchema.length > 0) {
                renderSourceTables();
            }
            
            console.log(`‚úÖ Interface atualizada para tipo: ${detectedType.toUpperCase()}`);
        }

        // Renderizar tabelas de origem
        function renderSourceTables() {
            const container = document.getElementById('sourceTablesList');
            container.innerHTML = '';

            sourceSchema.forEach(table => {
                const tableElement = createTableElement(table, 'source');
                container.appendChild(tableElement);
            });
        }

        // Renderizar tabelas de destino
        function renderTargetTables() {
            const container = document.getElementById('targetTablesList');
            container.innerHTML = '';

            targetSchema.forEach(table => {
                const tableElement = createTableElement(table, 'target');
                container.appendChild(tableElement);
            });
        }

        // Criar elemento de tabela
        function createTableElement(table, type) {
            const div = document.createElement('div');
            div.className = 'table-item';
            div.draggable = type === 'source';
            div.dataset.tableName = table.name;
            div.dataset.type = type;

            div.innerHTML = `
                <div class="table-name">${table.name}</div>
                <div class="table-info">${table.columns.length} colunas</div>
            `;

            div.addEventListener('click', () => selectTable(div, table, type));
            
            if (type === 'source') {
                div.addEventListener('dragstart', (e) => {
                    console.log(`üéØ DRAG iniciado - Tabela: "${table.name}"`);
                    e.dataTransfer.setData('text/plain', table.name);
                    e.dataTransfer.effectAllowed = 'copy';
                    div.classList.add('dragging');
                });

                div.addEventListener('dragend', () => {
                    console.log(`üéØ DRAG finalizado - Tabela: "${table.name}"`);
                    div.classList.remove('dragging');
                });
            } else {
                div.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    div.classList.add('drag-over');
                });

                div.addEventListener('dragleave', () => {
                    div.classList.remove('drag-over');
                });

                div.addEventListener('drop', (e) => {
                    e.preventDefault();
                    div.classList.remove('drag-over');
                    
                    const sourceTableName = e.dataTransfer.getData('text/plain');
                    console.log(`üéØ DROP detectado - Origem: "${sourceTableName}", Destino: "${table.name}"`);
                    
                    if (!sourceTableName) {
                        console.error('‚ùå Nome da tabela de origem n√£o encontrado no dataTransfer');
                        showStatus('‚ùå Erro no arrastar e soltar: dados n√£o encontrados', 'error');
                        return;
                    }
                    
                    if (!table.name) {
                        console.error('‚ùå Nome da tabela de destino n√£o encontrado');
                        showStatus('‚ùå Erro no arrastar e soltar: tabela de destino inv√°lida', 'error');
                        return;
                    }
                    
                    console.log(`üîó Iniciando cria√ß√£o de mapeamento 1:1...`);
                    createTableMapping(sourceTableName, table.name);
                });
            }

            return div;
        }

        // Filtrar tabelas por pesquisa
        function filterTables(type, searchTerm) {
            const container = document.getElementById(type === 'source' ? 'sourceTablesList' : 'targetTablesList');
            const tableItems = container.querySelectorAll('.table-item');
            
            const searchTermLower = searchTerm.toLowerCase().trim();
            
            tableItems.forEach(item => {
                const tableName = item.dataset.tableName.toLowerCase();
                const tableText = item.textContent.toLowerCase();
                
                // Verifica se o termo de pesquisa est√° no nome da tabela ou no texto completo
                const matches = tableName.includes(searchTermLower) || tableText.includes(searchTermLower);
                
                if (matches || searchTermLower === '') {
                    item.style.display = 'block';
                    item.style.opacity = '1';
                } else {
                    item.style.display = 'none';
                    item.style.opacity = '0';
                }
            });
            
            // Mostrar mensagem se nenhuma tabela for encontrada
            const visibleItems = Array.from(tableItems).filter(item => item.style.display !== 'none');
            
            // Remover mensagem anterior se existir
            const existingMessage = container.querySelector('.no-results-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // Adicionar mensagem se n√£o houver resultados
            if (visibleItems.length === 0 && searchTermLower !== '') {
                const noResultsDiv = document.createElement('div');
                noResultsDiv.className = 'no-results-message';
                noResultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #6c757d;">
                        <div style="font-size: 2rem; margin-bottom: 8px;">üîç</div>
                        <div style="font-weight: 500;">Nenhuma tabela encontrada</div>
                        <div style="font-size: 0.85rem; margin-top: 4px;">Tente outro termo de pesquisa</div>
                    </div>
                `;
                container.appendChild(noResultsDiv);
            }
            
            console.log(`üîç Filtro aplicado - Tipo: ${type}, Termo: "${searchTerm}", Resultados: ${visibleItems.length}`);
        }

        // Mostrar/ocultar bot√£o de limpar pesquisa
        function toggleClearButton(type, value) {
            const clearButton = document.getElementById(type === 'source' ? 'clearSourceSearch' : 'clearTargetSearch');
            if (value.trim() !== '') {
                clearButton.classList.add('show');
            } else {
                clearButton.classList.remove('show');
            }
        }

        // Limpar pesquisa de tabelas
        function clearTableSearch(type) {
            const searchInput = document.getElementById(type === 'source' ? 'sourceTablesSearch' : 'targetTablesSearch');
            const clearButton = document.getElementById(type === 'source' ? 'clearSourceSearch' : 'clearTargetSearch');
            
            searchInput.value = '';
            clearButton.classList.remove('show');
            filterTables(type, '');
            searchInput.focus();
        }

        // Selecionar tabela
        function selectTable(element, table, type) {
            // Remover sele√ß√£o anterior do mesmo tipo
            document.querySelectorAll(`.table-item.${type === 'source' ? 'selected' : 'target-selected'}`).forEach(item => {
                item.classList.remove(type === 'source' ? 'selected' : 'target-selected');
            });

            // Remover highlight de tabelas n√£o mapeadas
            element.classList.remove('highlight-unmapped');

            // Selecionar nova tabela
            element.classList.add(type === 'source' ? 'selected' : 'target-selected');

            if (type === 'source') {
                selectedSourceTable = table;
                showStatus(`üìã Tabela origem selecionada: ${table.name} (${table.columns.length} colunas)`, 'info');
            } else {
                selectedTargetTable = table;
                showStatus(`üéØ Tabela destino selecionada: ${table.name} (${table.columns.length} colunas)`, 'info');
            }

            // Atualizar informa√ß√µes de progresso
            updateMappingProgress();

            // Verificar se podemos criar um novo mapeamento
            if (selectedSourceTable && selectedTargetTable) {
                // Verificar se j√° existe mapeamento para essas tabelas
                const existingMapping = tableMappings.find(m => 
                    m.sourceTable === selectedSourceTable.name && 
                    m.targetTable === selectedTargetTable.name
                );

                if (existingMapping) {
                    showStatus(`‚ö†Ô∏è Mapeamento j√° existe: ${selectedSourceTable.name} ‚Üí ${selectedTargetTable.name}`, 'warning');
                    setTimeout(() => {
                        if (confirm(`üîÑ Mapeamento j√° existe para "${selectedSourceTable.name} ‚Üí ${selectedTargetTable.name}".\n\nDeseja editar este mapeamento existente?`)) {
                            editColumnMapping(existingMapping.id || existingMapping.sourceTable);
                        }
                    }, 1000);
                } else {
                    // Mostrar op√ß√£o para criar novo mapeamento
                    setTimeout(() => {
                        if (confirm(`‚ú® Criar novo mapeamento?\n\nüìã Origem: ${selectedSourceTable.name} (${selectedSourceTable.columns.length} colunas)\nüéØ Destino: ${selectedTargetTable.name} (${selectedTargetTable.columns.length} colunas)\n\nClique OK para iniciar o mapeamento de colunas.`)) {
                            createMappingFromSelection();
                        }
                    }, 500);
                }
            }
        }

        // Criar mapeamento a partir da sele√ß√£o atual
        function createMappingFromSelection() {
            if (!selectedSourceTable || !selectedTargetTable) {
                showStatus('‚ùå Selecione uma tabela de origem e uma de destino', 'error');
                return;
            }

            // Criar mapeamento manualmente
            const newMapping = {
                id: `${selectedSourceTable.name}_to_${selectedTargetTable.name}`,
                sourceTable: selectedSourceTable.name,
                targetTable: selectedTargetTable.name,
                type: 'one-to-one',
                confidence: 0.8,
                columnMappings: [],
                validated: false
            };

            tableMappings.push(newMapping);
            renderMappings();
            updateTableVisualStatus();
            updateMappingProgress();

            // Abrir interface de mapeamento de colunas
            editColumnMapping(newMapping.id);

            showStatus(`‚úÖ Novo mapeamento criado: ${selectedSourceTable.name} ‚Üí ${selectedTargetTable.name}`, 'success');

            // Limpar sele√ß√µes
            selectedSourceTable = null;
            selectedTargetTable = null;
            document.querySelectorAll('.table-item.selected, .table-item.target-selected').forEach(item => {
                item.classList.remove('selected', 'target-selected');
            });
            
            // Atualizar progresso ap√≥s limpar sele√ß√µes
            updateMappingProgress();
        }

        // Auto-mapear tabelas
        async function autoMapTables() {
            showStatus('ü§ñ Gerando mapeamentos autom√°ticos...', 'info');

            // Verificar se temos esquemas dispon√≠veis
            if (!sourceSchema.length || !targetSchema.length) {
                showStatus('‚ùå Execute primeiro a an√°lise de esquemas', 'error');
                return;
            }

            try {
                const response = await fetch('/api/auto-map-tables', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sourceSchema: { tables: sourceSchema },
                        targetSchema: { tables: targetSchema }
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    tableMappings = result.mappings;
                    renderMappings();
                    showStatus(`‚úÖ ${result.mappings.length} mapeamentos criados`, 'success');
                } else {
                    showStatus(`‚ùå Erro no auto-mapeamento: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Erro no auto-mapeamento: ${error.message}`, 'error');
            }
        }

        // Criar mapeamento manual
        function createManualMapping() {
            if (!selectedSourceTable || !selectedTargetTable) {
                showStatus('‚ùå Selecione uma tabela de origem e destino', 'error');
                return;
            }

            createTableMapping(selectedSourceTable.name, selectedTargetTable.name);
        }

        // Criar mapeamento de tabela
        async function createTableMapping(sourceTable, targetTable) {
            console.log(`üîó INICIANDO mapeamento: ${sourceTable} ‚Üí ${targetTable}`);
            
            // Buscar informa√ß√µes das tabelas nos esquemas
            const sourceTableInfo = sourceSchema.find(table => table.name === sourceTable);
            const targetTableInfo = targetSchema.find(table => table.name === targetTable);
            
            if (!sourceTableInfo || !targetTableInfo) {
                showStatus('‚ùå Informa√ß√µes das tabelas n√£o encontradas nos esquemas', 'error');
                return;
            }
            
            try {
                console.log('üì° Enviando requisi√ß√£o para /api/create-mapping...');
                
                const response = await fetch('/api/create-mapping', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        sourceTable, 
                        targetTable,
                        sourceColumns: sourceTableInfo.columns,
                        targetColumns: targetTableInfo.columns
                    })
                });

                console.log('üì° Resposta recebida:', response.status);
                const result = await response.json();
                console.log('üìã Resultado:', result);
                
                if (result.success) {
                    // Adicionar informa√ß√µes das colunas ao mapeamento
                    result.mapping.sourceColumns = sourceTableInfo.columns;
                    result.mapping.targetColumns = targetTableInfo.columns;
                    
                    tableMappings.push(result.mapping);
                    renderMappings();
                    updateTableVisualStatus(); // Atualizar indicadores visuais
                    showStatus(`‚úÖ Mapeamento criado: ${sourceTable} ‚Üí ${targetTable}`, 'success');
                    console.log('‚úÖ Mapeamento adicionado com sucesso');
                } else {
                    console.error('‚ùå Erro no resultado:', result.error);
                    showStatus(`‚ùå Erro ao criar mapeamento: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('‚ùå Erro na requisi√ß√£o:', error);
                showStatus(`‚ùå Erro ao criar mapeamento: ${error.message}`, 'error');
            }
        }

        // Renderizar mapeamentos
        function renderMappings() {
            const container = document.getElementById('mappingsList');
            container.innerHTML = '';

            // Filtrar apenas mapeamentos n√£o validados (os validados v√£o para aba de Migra√ß√£o)
            const pendingMappings = tableMappings.filter(mapping => !mapping.validated);

            if (pendingMappings.length === 0) {
                if (tableMappings.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #6c757d;">Nenhum mapeamento configurado</p>';
                } else {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); border-radius: 8px; border: 1px solid #c3e6cb; color: #155724;">
                            <div style="font-size: 2rem; margin-bottom: 10px;">‚úÖ</div>
                            <h4>Todos os mapeamentos foram validados!</h4>
                            <p style="margin: 10px 0;">Os mapeamentos validados est√£o dispon√≠veis na aba <strong>üöÄ Migra√ß√£o</strong></p>
                            <button class="btn btn-primary" onclick="document.querySelector('[data-tab=&quot;migration&quot;]').click()" style="margin-top: 10px;">
                                üöÄ Ir para Migra√ß√£o
                            </button>
                        </div>
                    `;
                }
                updateTableVisualStatus(); // Atualizar status mesmo quando vazio
                updateMappingProgress(); // Atualizar progresso
                return;
            }

            pendingMappings.forEach(mapping => {
                const mappingElement = createMappingElement(mapping);
                container.appendChild(mappingElement);
            });
            
            // Atualizar indicadores visuais das tabelas
            updateTableVisualStatus();
            
            // Atualizar informa√ß√µes de progresso
            updateMappingProgress();
            
            // Atualizar tamb√©m a vis√£o detalhada se estiver ativa
            const detailedView = document.getElementById('detailedMappingView');
            if (detailedView && detailedView.style.display !== 'none') {
                renderDetailedMappings();
            }
        }

        // Fun√ß√£o auxiliar para atualizar todas as visualiza√ß√µes de mapeamento
        function updateAllMappingViews() {
            renderMappings();
            updateTableVisualStatus();
            updateMappingProgress();
            
            // Re-renderizar a vis√£o detalhada se estiver ativa
            const detailedView = document.getElementById('detailedMappingView');
            if (detailedView && detailedView.style.display !== 'none') {
                renderDetailedMappings();
            }
        }

        // Criar elemento de mapeamento
        function createMappingElement(mapping) {
            const div = document.createElement('div');
            div.className = 'mapping-item';
            
            // Adicionar classe de valida√ß√£o se aplic√°vel
            if (mapping.validated) {
                div.classList.add('validated-mapping');
            }

            const confidenceClass = mapping.confidence >= 80 ? 'high' : 
                                   mapping.confidence >= 60 ? 'medium' : 'low';

            const mappedColumnsCount = mapping.columnMappings ? mapping.columnMappings.length : 0;
            const sourceColumnsCount = mapping.sourceColumns ? mapping.sourceColumns.length : 0;
            const targetColumnsCount = mapping.targetColumns ? mapping.targetColumns.length : 0;

            // Criar indicador de valida√ß√£o
            const validationBadge = mapping.validated ? 
                `<div class="validation-badge validated">
                    üéØ VALIDADO
                    <small style="display: block; font-size: 0.7rem; margin-top: 2px;">
                        ${new Date(mapping.validatedAt).toLocaleString('pt-BR')}
                    </small>
                </div>` : 
                `<div class="validation-badge pending">‚è≥ Pendente</div>`;

            div.innerHTML = `
                <div class="mapping-header">
                    <div class="mapping-title">
                        üìä ${mapping.sourceTable} ‚Üí ${mapping.targetTable}
                        ${mapping.validated ? ' üéØ' : ''}
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        ${validationBadge}
                        <div class="confidence-badge ${confidenceClass}">
                            ${Math.round(mapping.confidence)}% confian√ßa
                        </div>
                    </div>
                </div>
                <div style="margin-bottom: 10px;">
                    <strong>${mappedColumnsCount} colunas mapeadas</strong>
                    <span style="color: #6c757d; margin-left: 10px;">
                        (${sourceColumnsCount} origem ‚Üí ${targetColumnsCount} destino)
                    </span>
                </div>
                <div class="button-group" style="margin: 10px 0;">
                    <button class="btn btn-sm btn-primary" onclick="editColumnMapping('${mapping.id || mapping.sourceTable}')">
                        üîß Editar Colunas
                    </button>
                    <button class="btn btn-sm btn-info" onclick="showMappingDetails('${mapping.id || mapping.sourceTable}')">
                        üìã Detalhes
                    </button>
                    ${mapping.validated ? 
                        `<button class="btn btn-sm btn-secondary" onclick="unvalidateMapping('${mapping.id || mapping.sourceTable}')">
                            ‚Ü©Ô∏è Revalidar
                        </button>` :
                        ''
                    }
                    <button class="btn btn-sm btn-danger" onclick="removeMapping('${mapping.id || mapping.sourceTable}')">
                        üóëÔ∏è Remover
                    </button>
                </div>
                ${mapping.columnMappings && mapping.columnMappings.length > 0 ? `
                    <div class="column-mappings-preview">
                        ${mapping.columnMappings.slice(0, 3).map(col => `
                            <div class="column-mapping-item">
                                <span class="column-source">${col.sourceColumn} (${col.sourceType || 'N/A'})</span>
                                <span class="column-arrow">‚Üí</span>
                                <span class="column-target">${col.targetColumn} (${col.targetType || 'N/A'})</span>
                            </div>
                        `).join('')}
                        ${mapping.columnMappings.length > 3 ? `
                            <div style="text-align: center; color: #6c757d; margin-top: 5px;">
                                ... e mais ${mapping.columnMappings.length - 3} mapeamentos
                            </div>
                        ` : ''}
                    </div>
                ` : `
                    <div style="text-align: center; color: #6c757d; padding: 10px;">
                        ‚ö†Ô∏è Colunas n√£o mapeadas - Clique em "Editar Colunas" para configurar
                    </div>
                `}
            `;

            return div;
        }

        // Limpar mapeamentos com confirma√ß√£o dupla
        function clearMappings() {
            // Primeira confirma√ß√£o
            if (!confirm('‚ö†Ô∏è ATEN√á√ÉO: Esta a√ß√£o ir√° remover TODOS os mapeamentos, tabelas selecionadas, relacionamentos e configura√ß√µes de colunas.\n\nTem certeza que deseja continuar?')) {
                return;
            }
            
            // Segunda confirma√ß√£o mais espec√≠fica
            if (!confirm('üö® CONFIRMA√á√ÉO FINAL: Todos os dados de mapeamento ser√£o perdidos permanentemente!\n\n‚Ä¢ Mapeamentos de tabelas\n‚Ä¢ Relacionamentos entre tabelas\n‚Ä¢ Mapeamentos de colunas\n‚Ä¢ Sele√ß√µes ativas\n‚Ä¢ Configura√ß√µes de transforma√ß√£o\n\nEsta a√ß√£o N√ÉO PODE ser desfeita. Deseja realmente continuar?')) {
                return;
            }
            
            try {
                // Limpar todos os arrays de dados
                tableMappings = [];
                columnMappings = [];
                selectedSourceTables = [];
                selectedTargetTables = [];
                
                // Resetar sele√ß√µes atuais
                selectedSourceTable = null;
                selectedTargetTable = null;
                currentMapping = null;
                draggedColumn = null;
                
                // Limpar arrays de colunas
                sourceColumns = [];
                targetColumns = [];
                
                // Limpar interface visual - listas de mapeamentos
                const mappingsList = document.getElementById('mappingsList');
                if (mappingsList) {
                    mappingsList.innerHTML = '<div class="empty-state">Nenhum mapeamento configurado</div>';
                }
                
                const detailedMappingsList = document.getElementById('detailedMappingsList');
                if (detailedMappingsList) {
                    detailedMappingsList.innerHTML = '<div class="empty-state">Nenhum mapeamento detalhado dispon√≠vel</div>';
                }
                
                // Limpar interface visual - tabelas
                const sourceTablesList = document.getElementById('sourceTablesList');
                if (sourceTablesList) {
                    const tableItems = sourceTablesList.querySelectorAll('.table-item');
                    tableItems.forEach(item => {
                        item.classList.remove('selected', 'multi-selected', 'target-selected', 'mapped', 'partially-mapped', 'validated');
                    });
                }
                
                const targetTablesList = document.getElementById('targetTablesList');
                if (targetTablesList) {
                    const tableItems = targetTablesList.querySelectorAll('.table-item');
                    tableItems.forEach(item => {
                        item.classList.remove('selected', 'multi-selected', 'target-selected', 'mapped', 'partially-mapped', 'validated');
                    });
                }
                
                // Limpar interface visual - colunas
                const sourceColumnsList = document.getElementById('sourceColumnsList');
                if (sourceColumnsList) {
                    sourceColumnsList.innerHTML = '<div class="empty-state">Selecione uma tabela para ver as colunas</div>';
                }
                
                const targetColumnsList = document.getElementById('targetColumnsList');
                if (targetColumnsList) {
                    targetColumnsList.innerHTML = '<div class="empty-state">Selecione uma tabela para ver as colunas</div>';
                }
                
                // Atualizar informa√ß√µes de mapeamento atual
                const currentMappingInfo = document.getElementById('currentMappingInfo');
                if (currentMappingInfo) {
                    currentMappingInfo.textContent = 'Selecione um mapeamento para editar';
                }
                
                // Limpar elementos de estat√≠sticas espec√≠ficos (se existirem)
                const elementsToReset = ['totalMappingsCount', 'totalColumnMappingsCount', 'mappingReadinessPercent'];
                elementsToReset.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = '0';
                    }
                });
                
                // Renderizar mapeamentos vazios
                renderMappings();
                
                // Atualizar estat√≠sticas
                updateColumnMappingStats();
                
                // Mostrar confirma√ß√£o de sucesso
                showStatus('üóëÔ∏è Todos os mapeamentos, tabelas, relacionamentos e configura√ß√µes de colunas foram removidos com sucesso!', 'success');
                
                console.log('‚úÖ Limpeza completa realizada com sucesso');
                
            } catch (error) {
                console.error('‚ùå Erro ao limpar mapeamentos:', error);
                showStatus('‚ùå Erro ao limpar mapeamentos: ' + error.message, 'error');
            }
        }

        // Iniciar migra√ß√£o
        async function startMigration() {
            if (tableMappings.length === 0) {
                showStatus('‚ùå Configure pelo menos um mapeamento antes de migrar', 'error');
                return;
            }

            const batchSize = parseInt(document.getElementById('batchSize').value);

            showStatus('üöÄ Iniciando migra√ß√£o inteligente...', 'info');

            try {
                const response = await fetch('/api/start-migration', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        mappings: tableMappings,
                        batchSize 
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    showStatus('‚úÖ Migra√ß√£o iniciada', 'success');
                    
                    // Mudar para aba de monitoramento
                    document.querySelector('[data-tab="monitoring"]').click();
                } else {
                    showStatus(`‚ùå Erro ao iniciar migra√ß√£o: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Erro ao iniciar migra√ß√£o: ${error.message}`, 'error');
            }
        }

        // Atualizar progresso da migra√ß√£o
        function updateMigrationProgress(data) {
            const statusContainer = document.getElementById('migrationStatus');
            
            statusContainer.innerHTML = `
                <div style="max-width: 600px; margin: 0 auto;">
                    <h3>üöÄ Migra√ß√£o em Andamento</h3>
                    
                    <div style="margin: 20px 0;">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${data.progress}%"></div>
                        </div>
                        <p>${data.progress.toFixed(1)}% conclu√≠do</p>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div>
                            <strong>Tabela Atual:</strong> ${data.currentTable || 'N/A'}
                        </div>
                        <div>
                            <strong>Registros Processados:</strong> ${data.processedRows || 0}
                        </div>
                        <div>
                            <strong>Velocidade:</strong> ${data.throughput || 0} reg/s
                        </div>
                        <div>
                            <strong>Tempo Estimado:</strong> ${data.eta || 'Calculando...'}
                        </div>
                    </div>

                    ${data.errors && data.errors.length > 0 ? `
                        <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 15px; margin-top: 20px;">
                            <strong>‚ö†Ô∏è Erros Encontrados:</strong>
                            <ul style="margin-top: 10px;">
                                ${data.errors.map(error => `<li>${error}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // ============ COMPLEX MAPPING FUNCTIONS ============

        // State for multi-selection
        let selectedSourceTables = [];
        let selectedTargetTables = [];
        let isMultiSelectMode = false;

        // File explorer state
        let currentExplorerType = '';
        let currentPath = '';
        let selectedFile = '';
        let fileExplorerHistory = [];
        let fileExplorerHistoryIndex = -1;

        // Create Many-to-One mapping (Multiple source tables -> One target table)
        async function createManyToOneMapping() {
            isMultiSelectMode = true;
            selectedSourceTables = [];
            selectedTargetTables = [];
            
            showStatus('üìä Modo N:1 ativo - Selecione m√∫ltiplas tabelas de origem e uma de destino', 'info');
            
            // Update UI to show multi-select mode
            updateMultiSelectUI();
        }

        // Create One-to-Many mapping (One source table -> Multiple target tables)
        async function createOneToManyMapping() {
            isMultiSelectMode = true;
            selectedSourceTables = [];
            selectedTargetTables = [];
            
            showStatus('üîÄ Modo 1:N ativo - Selecione uma tabela de origem e m√∫ltiplas de destino', 'info');
            
            // Update UI to show multi-select mode
            updateMultiSelectUI();
        }

        // Update UI for multi-select mode
        function updateMultiSelectUI() {
            // Reset all selections
            document.querySelectorAll('.table-item').forEach(item => {
                item.classList.remove('selected', 'multi-selected', 'target-selected');
                const indicator = item.querySelector('.multi-select-indicator');
                if (indicator) indicator.remove();
            });

            // Add multi-select event listeners
            document.querySelectorAll('.table-item').forEach(item => {
                item.addEventListener('click', handleMultiSelect);
            });
        }

        // Handle multi-selection
        function handleMultiSelect(event) {
            event.stopPropagation();
            
            const tableItem = event.currentTarget;
            const tableName = tableItem.dataset.tableName;
            const type = tableItem.dataset.type;
            
            if (type === 'source') {
                if (selectedSourceTables.includes(tableName)) {
                    // Remove from selection
                    selectedSourceTables = selectedSourceTables.filter(t => t !== tableName);
                    tableItem.classList.remove('multi-selected');
                    const indicator = tableItem.querySelector('.multi-select-indicator');
                    if (indicator) indicator.remove();
                } else {
                    // Add to selection
                    selectedSourceTables.push(tableName);
                    tableItem.classList.add('multi-selected');
                    
                    // Add selection indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'multi-select-indicator';
                    indicator.textContent = selectedSourceTables.length;
                    tableItem.appendChild(indicator);
                }
            } else {
                if (selectedTargetTables.includes(tableName)) {
                    // Remove from selection
                    selectedTargetTables = selectedTargetTables.filter(t => t !== tableName);
                    tableItem.classList.remove('target-selected');
                    const indicator = tableItem.querySelector('.multi-select-indicator');
                    if (indicator) indicator.remove();
                } else {
                    // Add to selection
                    selectedTargetTables.push(tableName);
                    tableItem.classList.add('target-selected');
                    
                    // Add selection indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'multi-select-indicator';
                    indicator.textContent = selectedTargetTables.length;
                    tableItem.appendChild(indicator);
                }
            }

            // Check if we can create the mapping
            checkComplexMappingReady();
        }

        // Check if complex mapping is ready to be created
        function checkComplexMappingReady() {
            let canCreate = false;
            let mappingType = '';

            if (selectedSourceTables.length > 1 && selectedTargetTables.length === 1) {
                canCreate = true;
                mappingType = 'many-to-one';
            } else if (selectedSourceTables.length === 1 && selectedTargetTables.length > 1) {
                canCreate = true;
                mappingType = 'one-to-many';
            }

            if (canCreate) {
                // Show create mapping button
                showComplexMappingDialog(mappingType);
            }
        }

        // Show dialog to create complex mapping
        function showComplexMappingDialog(mappingType) {
            const dialog = document.createElement('div');
            dialog.className = 'complex-mapping-dialog';
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border-radius: 15px;
                padding: 30px;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 400px;
            `;

            const sourceList = selectedSourceTables.map(t => `‚Ä¢ ${t}`).join('<br>');
            const targetList = selectedTargetTables.map(t => `‚Ä¢ ${t}`).join('<br>');

            dialog.innerHTML = `
                <h3>üîó Criar Mapeamento ${mappingType === 'many-to-one' ? 'N:1' : '1:N'}</h3>
                
                <div style="margin: 20px 0;">
                    <strong>Tabelas de Origem:</strong><br>
                    ${sourceList}
                </div>
                
                <div style="margin: 20px 0;">
                    <strong>Tabelas de Destino:</strong><br>
                    ${targetList}
                </div>
                
                <div style="margin: 20px 0;">
                    <label><strong>Nome do Mapeamento:</strong></label>
                    <input type="text" id="complexMappingName" 
                           value="${mappingType}_${Date.now()}" 
                           style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="cancelComplexMapping()">Cancelar</button>
                    <button class="btn" onclick="confirmComplexMapping('${mappingType}')">Criar Mapeamento</button>
                </div>
            `;

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.className = 'complex-mapping-backdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;

            document.body.appendChild(backdrop);
            document.body.appendChild(dialog);
        }

        // Cancel complex mapping
        function cancelComplexMapping() {
            // Remove dialogs
            const dialog = document.querySelector('.complex-mapping-dialog');
            const backdrop = document.querySelector('.complex-mapping-backdrop');
            if (dialog) dialog.remove();
            if (backdrop) backdrop.remove();

            // Reset selections
            resetMultiSelect();
        }

        // Confirm complex mapping creation
        async function confirmComplexMapping(mappingType) {
            const mappingName = document.getElementById('complexMappingName').value;
            
            if (!mappingName.trim()) {
                showStatus('‚ùå Digite um nome para o mapeamento', 'error');
                return;
            }

            try {
                const response = await fetch('/api/create-complex-mapping', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        mappingType,
                        name: mappingName,
                        sourceTables: selectedSourceTables,
                        targetTables: selectedTargetTables
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    tableMappings.push(result.mapping);
                    renderMappings();
                    showStatus(`‚úÖ Mapeamento ${mappingType} criado: ${mappingName}`, 'success');
                    
                    // Clean up
                    cancelComplexMapping();
                } else {
                    showStatus(`‚ùå Erro ao criar mapeamento: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Erro ao criar mapeamento: ${error.message}`, 'error');
            }
        }

        // Reset multi-select mode
        function resetMultiSelect() {
            isMultiSelectMode = false;
            selectedSourceTables = [];
            selectedTargetTables = [];
            
            document.querySelectorAll('.table-item').forEach(item => {
                item.classList.remove('selected', 'multi-selected', 'target-selected');
                const indicator = item.querySelector('.multi-select-indicator');
                if (indicator) indicator.remove();
                
                // Remove multi-select event listeners
                item.removeEventListener('click', handleMultiSelect);
            });
        }

        // Detect relationships automatically
        async function detectRelationships() {
            showStatus('üîó Detectando relacionamentos automaticamente...', 'info');

            try {
                const response = await fetch('/api/detect-relationships', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();
                
                if (result.success) {
                    showStatus(`‚úÖ ${result.relationships.length} relacionamentos detectados`, 'success');
                    
                    // Show relationships dialog
                    showRelationshipsDialog(result.relationships);
                } else {
                    showStatus(`‚ùå Erro na detec√ß√£o: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Erro na detec√ß√£o: ${error.message}`, 'error');
            }
        }

        // Show Paradox-specific transformations
        async function showParadoxTransformations() {
            showStatus('‚ö° Aplicando transforma√ß√µes Paradox‚ÜíFirebird...', 'info');

            try {
                const response = await fetch('/api/paradox-transformations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();
                
                if (result.success) {
                    showStatus(`‚úÖ ${result.transformations.length} transforma√ß√µes aplicadas`, 'success');
                    
                    // Refresh mappings to show transformations
                    renderMappings();
                } else {
                    showStatus(`‚ùå Erro nas transforma√ß√µes: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Erro nas transforma√ß√µes: ${error.message}`, 'error');
            }
        }

        // Show relationships dialog
        function showRelationshipsDialog(relationships) {
            const dialog = document.createElement('div');
            dialog.className = 'relationships-dialog';
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border-radius: 15px;
                padding: 30px;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 600px;
                max-height: 70vh;
                overflow-y: auto;
            `;

            const relationshipsList = relationships.map(rel => `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #28a745;">
                    <strong>${rel.sourceTable}.${rel.sourceColumn}</strong> 
                    <span style="color: #667eea;">‚Üí</span> 
                    <strong>${rel.targetTable}.${rel.targetColumn}</strong>
                    <br>
                    <small style="color: #6c757d;">Tipo: ${rel.joinType} JOIN</small>
                </div>
            `).join('');

            dialog.innerHTML = `
                <h3>üîó Relacionamentos Detectados</h3>
                
                <div style="margin: 20px 0; max-height: 300px; overflow-y: auto;">
                    ${relationshipsList}
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="closeRelationshipsDialog()">Fechar</button>
                    <button class="btn" onclick="applyDetectedRelationships()">Aplicar Relacionamentos</button>
                </div>
            `;

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.className = 'relationships-backdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;

            document.body.appendChild(backdrop);
            document.body.appendChild(dialog);
        }

        // Close relationships dialog
        function closeRelationshipsDialog() {
            const dialog = document.querySelector('.relationships-dialog');
            const backdrop = document.querySelector('.relationships-backdrop');
            if (dialog) dialog.remove();
            if (backdrop) backdrop.remove();
        }

        // Apply detected relationships
        async function applyDetectedRelationships() {
            try {
                const response = await fetch('/api/apply-relationships', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();
                
                if (result.success) {
                    showStatus('‚úÖ Relacionamentos aplicados aos mapeamentos', 'success');
                    renderMappings();
                    closeRelationshipsDialog();
                } else {
                    showStatus(`‚ùå Erro ao aplicar relacionamentos: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`‚ùå Erro ao aplicar relacionamentos: ${error.message}`, 'error');
            }
        }

        // Enhanced renderMappings to show mapping types and transformations
        function renderMappings() {
            const container = document.getElementById('mappingsList');
            
            // Filtrar apenas mapeamentos n√£o validados (os validados v√£o para aba de Migra√ß√£o)
            const pendingMappings = tableMappings.filter(mapping => !mapping.validated);
            
            if (pendingMappings.length === 0) {
                if (tableMappings.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 40px;">Nenhum mapeamento configurado</p>';
                } else {
                    container.innerHTML = `
                        <div class="alert alert-success" style="text-align: center;">
                            ‚úÖ Todos os mapeamentos foram validados e transferidos para a aba <strong>üìä MIGRA√á√ÉO</strong>!
                            <br><br>
                            <button class="btn btn-primary" onclick="document.querySelector('[data-tab=&quot;migration&quot;]').click()">
                                üöÄ Ir para Migra√ß√£o
                            </button>
                        </div>
                    `;
                }
                return;
            }

            container.innerHTML = pendingMappings.map(mapping => {
                const mappingTypeClass = mapping.mappingType || 'one-to-one';
                const mappingTypeLabel = {
                    'one-to-one': '1:1',
                    'many-to-one': 'N:1',
                    'one-to-many': '1:N'
                }[mappingTypeClass] || '1:1';

                const hasParadoxTransforms = mapping.columnMappings?.some(cm => 
                    cm.transformation?.paradoxType) || false;

                return `
                    <div class="mapping-item ${mappingTypeClass}">
                        <div class="mapping-type-badge ${mappingTypeClass}">${mappingTypeLabel}</div>
                        
                        <div class="mapping-header">
                            <div class="mapping-title">
                                üîó ${mapping.sourceTable} ‚Üí ${mapping.targetTable}
                                ${hasParadoxTransforms ? '<span class="paradox-transformation-indicator">PDX‚ÜíFB</span>' : ''}
                                <span class="validation-badge pending">‚è≥ PENDENTE</span>
                            </div>
                            <div class="confidence-badge ${mapping.confidence > 0.8 ? 'high' : mapping.confidence > 0.5 ? 'medium' : 'low'}">
                                ${Math.round(mapping.confidence * 100)}%
                            </div>
                        </div>
                        
                        <div style="margin-top: 15px;">
                            ${mapping.columnMappings?.slice(0, 5).map(cm => `
                                <div class="column-mappings">
                                    <div class="column-source">
                                        ${cm.sourceColumn}
                                        ${cm.transformation?.paradoxType ? 
                                          `<small style="color: #dc3545;">(${cm.transformation.paradoxType})</small>` : ''}
                                    </div>
                                    <div class="column-arrow">‚Üí</div>
                                    <div class="column-target">
                                        ${cm.targetColumn}
                                        ${cm.transformation?.firebirdType ? 
                                          `<small style="color: #28a745;">(${cm.transformation.firebirdType})</small>` : ''}
                                    </div>
                                </div>
                            `).join('') || ''}
                            
                            ${mapping.columnMappings?.length > 5 ? 
                              `<div style="text-align: center; color: #6c757d; margin-top: 10px;">
                                 ... e mais ${mapping.columnMappings.length - 5} colunas
                               </div>` : ''}
                        </div>
                        
                        <div class="button-group" style="margin-top: 10px;">
                            <button class="btn btn-sm btn-info" onclick="editColumnMapping('${mapping.id || mapping.sourceTable}')">
                                ‚úèÔ∏è Editar
                            </button>
                            <button class="btn btn-sm btn-success" onclick="validateSpecificMapping('${mapping.id || mapping.sourceTable}')">
                                ‚úÖ Validar ‚Üí Migra√ß√£o
                            </button>
                            <button class="btn btn-sm btn-danger" onclick="deleteMapping('${mapping.id || mapping.sourceTable}')">
                                üóëÔ∏è Excluir
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ============ END COMPLEX MAPPING FUNCTIONS ============

        // ============ FILE EXPLORER FUNCTIONS ============

        // Fun√ß√£o para for√ßar visibilidade do SQLite - vers√£o melhorada
        function forceShowSQLite() {
            console.log('üîç For√ßando exibi√ß√£o do SQLite...');
            
            const sourceTypeElement = document.getElementById('sourceType');
            if (!sourceTypeElement) {
                const errorMsg = '‚ùå Elemento sourceType n√£o encontrado!';
                console.error(errorMsg);
                showStatus(errorMsg, 'error');
                alert(errorMsg);
                return;
            }
            
            try {
                console.log('üîß Aplicando corre√ß√µes de visibilidade...');
                
                // Remover qualquer estilo que possa estar escondendo o elemento
                sourceTypeElement.style.display = 'block';
                sourceTypeElement.style.visibility = 'visible';
                sourceTypeElement.style.opacity = '1';
                sourceTypeElement.style.position = 'static';
                sourceTypeElement.style.zIndex = 'auto';
                
                // For√ßar reflow do DOM
                sourceTypeElement.offsetHeight;
                
                // Verificar se SQLite existe
                let sqliteOption = sourceTypeElement.querySelector('option[value="sqlite"]');
                
                if (!sqliteOption) {
                    console.log('üîß SQLite n√£o encontrado, criando op√ß√£o...');
                    
                    // Criar op√ß√£o SQLite se n√£o existir
                    sqliteOption = document.createElement('option');
                    sqliteOption.value = 'sqlite';
                    sqliteOption.textContent = 'üóÉÔ∏è SQLite (.db, .sqlite, .sqlite3)';
                    sqliteOption.style.display = 'block';
                    sqliteOption.style.visibility = 'visible';
                    
                    // Adicionar como segunda op√ß√£o (ap√≥s Paradox)
                    if (sourceTypeElement.children.length > 1) {
                        sourceTypeElement.insertBefore(sqliteOption, sourceTypeElement.children[1]);
                    } else {
                        sourceTypeElement.appendChild(sqliteOption);
                    }
                    
                    console.log('‚úÖ Op√ß√£o SQLite criada e adicionada');
                }
                
                // Garantir visibilidade da op√ß√£o SQLite
                sqliteOption.style.display = 'block';
                sqliteOption.style.visibility = 'visible';
                sqliteOption.disabled = false;
                
                // Selecionar SQLite
                const oldValue = sourceTypeElement.value;
                sourceTypeElement.value = 'sqlite';
                
                // Disparar eventos para atualizar interface
                sourceTypeElement.dispatchEvent(new Event('change', { bubbles: true }));
                updateSourceInterface();
                
                // Destacar visualmente
                sourceTypeElement.style.border = '3px solid #28a745';
                sourceTypeElement.style.backgroundColor = '#e8f5e8';
                sourceTypeElement.style.boxShadow = '0 0 10px rgba(40, 167, 69, 0.5)';
                
                // Remover destaque ap√≥s alguns segundos
                setTimeout(() => {
                    sourceTypeElement.style.border = '';
                    sourceTypeElement.style.backgroundColor = '';
                    sourceTypeElement.style.boxShadow = '';
                }, 4000);
                
                // Verificar resultado
                const totalOptions = sourceTypeElement.children.length;
                const currentValue = sourceTypeElement.value;
                
                const successMsg = `‚úÖ SQLite for√ßado com sucesso!\n\n` +
                                 `Op√ß√µes totais: ${totalOptions}\n` +
                                 `Valor anterior: ${oldValue}\n` +
                                 `Valor atual: ${currentValue}\n` +
                                 `Texto da op√ß√£o: ${sqliteOption.textContent}`;
                
                console.log(successMsg);
                showStatus('üóÉÔ∏è SQLite ativado e interface atualizada!', 'success');
                alert(successMsg);
                
                // Sugerir pr√≥ximo passo
                if (confirm('SQLite ativado com sucesso!\n\nDeseja selecionar um arquivo SQLite agora?')) {
                    setTimeout(() => openNativeFileDialog('source'), 500);
                }
                
            } catch (error) {
                const errorMsg = `‚ùå Erro ao for√ßar SQLite: ${error.message}`;
                console.error(errorMsg, error);
                showStatus(errorMsg, 'error');
                alert(errorMsg);
            }
        }

        // Fun√ß√£o de teste para debug do dialog - vers√£o melhorada
        async function testFileDialog() {
            console.log('üîß Iniciando teste de dialog...');
            
            const sourceTypeElement = document.getElementById('sourceType');
            if (!sourceTypeElement) {
                alert('‚ùå ERRO: Elemento sourceType n√£o encontrado!');
                return;
            }
            
            const currentType = sourceTypeElement.value;
            const typeLabel = getTypeLabelForDisplay(currentType);
            
            showStatus(`üîß Testando seletor de arquivos para ${typeLabel}...`, 'info');
            
            try {
                console.log('üìã Configura√ß√£o do teste:');
                console.log('  - Tipo selecionado:', currentType);
                console.log('  - Label:', typeLabel);
                
                alert(`üîß Teste do Dialog\n\nTipo: ${typeLabel}\nVou abrir o seletor de arquivo...`);
                
                // Chamar fun√ß√£o de abertura de dialog
                const result = await openNativeFileDialog('source');
                
                if (result) {
                    console.log('‚úÖ Resultado do dialog:', result);
                    const successMsg = `‚úÖ Arquivo selecionado com sucesso!\n\nCaminho: ${result}\nTipo: ${typeLabel}`;
                    
                    showStatus('‚úÖ Teste de dialog bem-sucedido!', 'success');
                    alert(successMsg);
                    
                    // Verificar se o arquivo foi definido no input
                    const pathInput = document.getElementById('sourcePath');
                    if (pathInput && pathInput.value) {
                        console.log('‚úÖ Arquivo definido no input:', pathInput.value);
                        
                        // Tentar teste de conex√£o autom√°tico
                        if (confirm('Arquivo selecionado com sucesso!\nDeseja testar a conex√£o automaticamente?')) {
                            setTimeout(() => testSourceConnection(), 500);
                        }
                    }
                    
                } else {
                    console.log('üìÇ Sele√ß√£o cancelada ou erro');
                    showStatus('üìÇ Sele√ß√£o cancelada pelo usu√°rio', 'warning');
                    alert('üìÇ Sele√ß√£o cancelada ou nenhum arquivo foi selecionado');
                }
                
            } catch (error) {
                console.error('‚ùå Erro no teste de dialog:', error);
                const errorMsg = `‚ùå Erro no teste: ${error.message}`;
                
                showStatus(errorMsg, 'error');
                alert(`‚ùå Erro durante o teste do dialog:\n\n${error.message}\n\nVerifique o console para mais detalhes.`);
            }
        }

        // Fun√ß√£o para abrir o seletor nativo de arquivos do Windows com fallback HTML5
        async function openNativeFileDialog(type) {
            try {
                console.log('üî• openNativeFileDialog chamada com tipo:', type);
                showStatus(`üóÇÔ∏è Abrindo seletor de arquivos...`, 'info');
                
                const sourceTypeElement = document.getElementById('sourceType');
                const sourceType = sourceTypeElement?.value || 'paradox';
                let fileType = type === 'source' ? sourceType : 'firebird';
                
                console.log('üìã Tipo de arquivo detectado:', fileType);
                
                const requestBody = {
                    type: fileType,
                    title: type === 'source' ? 'Selecionar Banco de Origem' : 'Selecionar Banco de Destino'
                };
                
                console.log('üì§ Enviando requisi√ß√£o:', requestBody);
                
                const response = await fetch('/api/open-file-dialog', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('üì• Resposta recebida:', response.status);
                
                if (!response.ok) {
                    throw new Error(`Erro HTTP: ${response.status}`);
                }

                const result = await response.json();
                console.log('üìã Resultado completo:', result);
                
                // Se deve usar fallback HTML5
                if (result.useFallback || !result.success) {
                    console.log('üîÑ Usando fallback HTML5...');
                    showStatus('üåê Usando seletor HTML5...', 'info');
                    return openHTML5FileDialog(type, result.extensions || '.db,.sqlite,.sqlite3');
                }
                
                if (result.success && !result.cancelled && result.selectedFile) {
                    return handleFileSelection(type, result.selectedFile);
                } else if (result.cancelled) {
                    console.log('üìÇ Sele√ß√£o cancelada pelo usu√°rio');
                    showStatus('üìÇ Sele√ß√£o cancelada', 'info');
                    return null;
                } else {
                    console.error('‚ùå Erro na resposta:', result);
                    showStatus('‚ùå Erro ao abrir seletor de arquivos', 'error');
                    return null;
                }
            } catch (error) {
                console.error('üí• Erro no seletor nativo:', error);
                showStatus('üîÑ Tentando seletor HTML5...', 'info');
                return openHTML5FileDialog(type, '.db,.sqlite,.sqlite3,.fdb,.gdb,.pdx,.px');
            }
        }

        // Fun√ß√£o para usar seletor HTML5 como fallback
        function openHTML5FileDialog(type, extensions) {
            return new Promise((resolve, reject) => {
                console.log('üåê Abrindo seletor HTML5...');
                
                // Criar input file tempor√°rio
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = extensions;
                fileInput.style.display = 'none';
                
                // Event listeners
                fileInput.addEventListener('change', function(event) {
                    const file = event.target.files[0];
                    if (file) {
                        console.log('üìÅ Arquivo selecionado via HTML5:', file.name);
                        
                        // Simular caminho do arquivo (limita√ß√£o do browser)
                        const simulatedPath = `C:\\Users\\GIGAINFORMATICA\\Desktop\\${file.name}`;
                        
                        handleFileSelection(type, simulatedPath, file)
                            .then(result => {
                                resolve(result);
                                document.body.removeChild(fileInput);
                            })
                            .catch(error => {
                                reject(error);
                                document.body.removeChild(fileInput);
                            });
                    } else {
                        console.log('üìÇ Nenhum arquivo selecionado');
                        showStatus('üìÇ Nenhum arquivo selecionado', 'info');
                        resolve(null);
                        document.body.removeChild(fileInput);
                    }
                });

                fileInput.addEventListener('cancel', function() {
                    console.log('üìÇ Sele√ß√£o cancelada');
                    showStatus('üìÇ Sele√ß√£o cancelada', 'info');
                    resolve(null);
                    document.body.removeChild(fileInput);
                });
                
                // Adicionar ao DOM e clicar
                document.body.appendChild(fileInput);
                fileInput.click();
            });
        }

        // Fun√ß√£o para processar arquivo selecionado (tanto nativo quanto HTML5)
        async function handleFileSelection(type, filePath, fileObject = null) {
            try {
                console.log('üéØ Processando sele√ß√£o de arquivo:', filePath);
                
                // Definir no campo de input
                const inputField = type === 'source' ? 'sourcePath' : 'targetDatabase';
                const inputElement = document.getElementById(inputField);
                
                if (inputElement) {
                    inputElement.value = filePath;
                    console.log('‚úÖ Arquivo definido no input:', filePath);
                }
                
                // Auto-detectar tipo se for origem - mas respeitar escolha do usu√°rio
                if (type === 'source') {
                    const detectedType = detectDatabaseType(filePath);
                    console.log('üîç Tipo detectado:', detectedType);
                    
                    const sourceTypeElement = document.getElementById('sourceType');
                    const currentType = sourceTypeElement?.value || 'paradox';
                    
                    // S√≥ alterar o tipo se:
                    // 1. O tipo detectado for espec√≠fico (n√£o unknown)
                    // 2. E for diferente do tipo atual
                    // 3. E o arquivo tiver extens√£o espec√≠fica (.pdx, .px, .sqlite, .sqlite3, .fdb, .gdb)
                    if (detectedType !== 'unknown' && detectedType !== currentType) {
                        console.log(`üîÑ Alterando tipo de ${currentType} para ${detectedType} (extens√£o espec√≠fica detectada)`);
                        sourceTypeElement.value = detectedType;
                        updateSourceInterface();
                        showStatus(`üîç Tipo detectado automaticamente: ${detectedType === 'sqlite' ? 'SQLite' : detectedType === 'paradox' ? 'Paradox' : 'Firebird'}`, 'info');
                    } else if (detectedType === 'unknown') {
                        console.log(`üìã Mantendo tipo ${currentType} (arquivo .db - pode ser SQLite ou Paradox)`);
                        showStatus(`üìã Mantendo tipo ${currentType === 'sqlite' ? 'SQLite' : 'Paradox'} - arquivo .db compat√≠vel`, 'info');
                    } else {
                        console.log(`‚úÖ Tipo ${currentType} confirmado pela extens√£o do arquivo`);
                    }
                }
                
                // Salvar nos arquivos recentes
                saveRecentFile(type, filePath);
                loadRecentFiles();
                
                // Notificar servidor se for arquivo HTML5 com objeto
                if (fileObject) {
                    try {
                        await fetch('/api/file-selected', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                filePath: filePath,
                                fileName: fileObject.name,
                                type: type,
                                size: fileObject.size,
                                lastModified: fileObject.lastModified
                            })
                        });
                    } catch (notifyError) {
                        console.warn('‚ö†Ô∏è Erro ao notificar servidor:', notifyError);
                    }
                }
                
                showStatus(`‚úÖ Arquivo selecionado: ${filePath}`, 'success');
                
                // Auto-testar conex√£o
                if (type === 'source') {
                    setTimeout(() => testSourceConnection(), 1000);
                } else {
                    setTimeout(() => testTargetConnection(), 1000);
                }
                
                return filePath;
                
            } catch (error) {
                console.error('‚ùå Erro ao processar arquivo:', error);
                showStatus(`‚ùå Erro ao processar arquivo: ${error.message}`, 'error');
                throw error;
            }
        }

        // Fun√ß√£o para atualizar interface baseada no tipo de origem
        function updateSourceInterface() {
            console.log('üîÑ Atualizando interface...');
            
            const sourceTypeElement = document.getElementById('sourceType');
            const pathInput = document.getElementById('sourcePath');
            
            if (!sourceTypeElement) {
                console.error('‚ùå Elemento sourceType n√£o encontrado!');
                return;
            }
            
            const sourceType = sourceTypeElement.value;
            console.log('üìã Tipo selecionado:', sourceType);
            
            if (!pathInput) {
                console.error('‚ùå Elemento sourcePath n√£o encontrado!');
                return;
            }
            
            // Atualizar placeholder baseado no tipo
            if (sourceType === 'paradox') {
                pathInput.placeholder = 'Clique em "Procurar" para selecionar arquivo Paradox (.db, .pdx, .px)...';
            } else if (sourceType === 'sqlite') {
                pathInput.placeholder = 'Clique em "Procurar" para selecionar arquivo SQLite (.db, .sqlite, .sqlite3)...';
            }
            
            // Limpar sele√ß√£o atual
            pathInput.value = '';
            
            // Atualizar t√≠tulo da se√ß√£o
            const sectionTitle = document.querySelector('#connection .connection-card h3');
            if (sectionTitle) {
                const typeLabel = sourceType === 'sqlite' ? 'SQLite' : 'Paradox';
                sectionTitle.innerHTML = `üìÅ Banco de Origem (${typeLabel})`;
                console.log('üìù T√≠tulo atualizado para:', typeLabel);
            }
            
            // Recarregar arquivos recentes filtrados por tipo
            loadRecentFiles();
            
            console.log('‚úÖ Interface atualizada!');
        }

        // Fun√ß√£o para detectar tipo de banco automaticamente pela extens√£o
        function detectDatabaseType(filePath) {
            const ext = filePath.toLowerCase().split('.').pop();
            
            if (['pdx', 'px'].includes(ext)) {
                return 'paradox';
            } else if (['sqlite', 'sqlite3'].includes(ext)) {
                return 'sqlite';
            } else if (ext === 'db') {
                // .db pode ser Paradox ou SQLite - retornar unknown para n√£o sobrescrever escolha do usu√°rio
                return 'unknown';
            } else if (['fdb', 'gdb'].includes(ext)) {
                return 'firebird';
            }
            
            return 'unknown';
        }

        // Fun√ß√£o de teste para SQLite - vers√£o melhorada
        function testSQLiteInterface() {
            console.log('üß™ Testando interface SQLite...');
            
            const sourceTypeElement = document.getElementById('sourceType');
            
            if (!sourceTypeElement) {
                const errorMsg = '‚ùå ERRO: Elemento sourceType n√£o encontrado!';
                console.error(errorMsg);
                showStatus(errorMsg, 'error');
                alert(errorMsg);
                return;
            }
            
            try {
                // Log do estado atual
                console.log('üîç Estado atual do select:');
                console.log('  - Valor atual:', sourceTypeElement.value);
                console.log('  - N√∫mero de op√ß√µes:', sourceTypeElement.children.length);
                
                // Listar todas as op√ß√µes dispon√≠veis
                const options = [];
                for (let i = 0; i < sourceTypeElement.children.length; i++) {
                    const option = sourceTypeElement.children[i];
                    options.push(`${option.value}: ${option.textContent}`);
                    console.log(`  - Op√ß√£o ${i + 1}: ${option.value} = "${option.textContent}"`);
                }
                
                // Verificar se SQLite existe
                const sqliteOption = sourceTypeElement.querySelector('option[value="sqlite"]');
                
                if (sqliteOption) {
                    // SQLite encontrado - selecionar e atualizar interface
                    console.log('‚úÖ Op√ß√£o SQLite encontrada!');
                    
                    const oldValue = sourceTypeElement.value;
                    sourceTypeElement.value = 'sqlite';
                    
                    // Disparar evento de mudan√ßa para atualizar interface
                    const changeEvent = new Event('change', { bubbles: true });
                    sourceTypeElement.dispatchEvent(changeEvent);
                    
                    // Atualizar interface manualmente tamb√©m
                    updateSourceInterface();
                    
                    const successMsg = `‚úÖ Interface alterada para SQLite!\n` +
                                     `Valor anterior: ${oldValue}\n` +
                                     `Valor atual: ${sourceTypeElement.value}\n` +
                                     `Op√ß√µes dispon√≠veis: ${options.length}`;
                    
                    console.log(successMsg);
                    showStatus('üóÉÔ∏è Interface SQLite ativada com sucesso!', 'success');
                    alert(successMsg);
                    
                    // Destacar visualmente o select por um momento
                    sourceTypeElement.style.border = '3px solid #28a745';
                    sourceTypeElement.style.backgroundColor = '#e8f5e8';
                    
                    setTimeout(() => {
                        sourceTypeElement.style.border = '';
                        sourceTypeElement.style.backgroundColor = '';
                    }, 3000);
                    
                } else {
                    // SQLite n√£o encontrado - tentar adicionar
                    const errorMsg = `‚ùå Op√ß√£o SQLite N√ÉO encontrada!\nOp√ß√µes dispon√≠veis: ${options.join(', ')}`;
                    console.error(errorMsg);
                    
                    if (confirm('Op√ß√£o SQLite n√£o encontrada. Deseja tentar adicionar dinamicamente?')) {
                        const newOption = document.createElement('option');
                        newOption.value = 'sqlite';
                        newOption.textContent = 'üóÉÔ∏è SQLite (.db, .sqlite, .sqlite3)';
                        sourceTypeElement.appendChild(newOption);
                        
                        // Selecionar a nova op√ß√£o
                        sourceTypeElement.value = 'sqlite';
                        updateSourceInterface();
                        
                        showStatus('üóÉÔ∏è Op√ß√£o SQLite adicionada e ativada!', 'success');
                        alert('‚úÖ Op√ß√£o SQLite adicionada dinamicamente e selecionada!');
                    } else {
                        showStatus('‚ùå Teste SQLite cancelado', 'warning');
                    }
                }
                
            } catch (error) {
                const errorMsg = `‚ùå Erro durante teste SQLite: ${error.message}`;
                console.error(errorMsg, error);
                showStatus(errorMsg, 'error');
                alert(errorMsg);
            }
        }

        // Open file explorer for source or target (navegador interno)
        function openFileExplorer(type) {
            currentExplorerType = type;
            
            // Start from user's Documents or common database paths
            const initialPath = type === 'source' ? 'C:\\' : 'C:\\';
            
            createFileExplorerModal(type);
            navigateToPath(initialPath);
        }

        // Create file explorer modal
        function createFileExplorerModal(type) {
            const modal = document.createElement('div');
            modal.className = 'file-explorer-modal';
            modal.id = 'fileExplorerModal';
            
            const title = type === 'source' ? 'Selecionar Banco Paradox' : 'Selecionar Banco Firebird';
            const extensions = type === 'source' ? '.db, .pdx, .px' : '.fdb, .gdb';
            
            modal.innerHTML = `
                <div class="file-explorer-content">
                    <div class="file-explorer-header">
                        <div class="file-explorer-title">${title}</div>
                        <button class="close-explorer" onclick="closeFileExplorer()">√ó</button>
                    </div>
                    
                    <div class="file-explorer-navigation">
                        <button class="nav-button" id="backButton" onclick="navigateBack()" disabled>‚Üê Voltar</button>
                        <button class="nav-button" id="forwardButton" onclick="navigateForward()" disabled>Avan√ßar ‚Üí</button>
                        <button class="nav-button" onclick="navigateUp()">‚Üë Subir</button>
                        <input type="text" class="current-path" id="currentPathInput" readonly>
                        <button class="nav-button" onclick="refreshCurrentPath()">üîÑ Atualizar</button>
                    </div>
                    
                    <div class="file-explorer-body">
                        <div class="file-list" id="fileList">
                            <div style="text-align: center; padding: 40px; color: #6c757d;">
                                Carregando...
                            </div>
                        </div>
                    </div>
                    
                    <div class="file-explorer-footer">
                        <div class="selected-file-info" id="selectedFileInfo">
                            Tipos suportados: ${extensions}
                        </div>
                        <div class="explorer-actions">
                            <button class="btn btn-secondary" onclick="closeFileExplorer()">Cancelar</button>
                            <button class="btn" id="selectFileButton" onclick="selectCurrentFile()" disabled>Selecionar</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // Navigate to specific path
        async function navigateToPath(path) {
            currentPath = path;
            document.getElementById('currentPathInput').value = path;
            
            // Add to history
            if (fileExplorerHistoryIndex === -1 || fileExplorerHistory[fileExplorerHistoryIndex] !== path) {
                fileExplorerHistory = fileExplorerHistory.slice(0, fileExplorerHistoryIndex + 1);
                fileExplorerHistory.push(path);
                fileExplorerHistoryIndex = fileExplorerHistory.length - 1;
            }
            
            updateNavigationButtons();
            
            try {
                const response = await fetch('/api/browse-path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        path: path,
                        type: currentExplorerType 
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayFileList(result.items);
                } else {
                    displayFileList([]);
                    showStatus(`Erro ao acessar caminho: ${result.error}`, 'error');
                }
            } catch (error) {
                displayFileList([]);
                showStatus(`Erro na navega√ß√£o: ${error.message}`, 'error');
            }
        }

        // Display file list
        function displayFileList(items) {
            const fileList = document.getElementById('fileList');
            
            if (items.length === 0) {
                fileList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #6c757d;">
                        üìÅ Pasta vazia ou sem permiss√£o de acesso
                    </div>
                `;
                return;
            }
            
            // Sort: folders first, then files
            items.sort((a, b) => {
                if (a.isDirectory !== b.isDirectory) {
                    return a.isDirectory ? -1 : 1;
                }
                return a.name.localeCompare(b.name);
            });
            
            fileList.innerHTML = items.map(item => {
                const icon = getFileIcon(item);
                const size = item.isDirectory ? '' : formatFileSize(item.size);
                const date = new Date(item.modified).toLocaleDateString('pt-BR');
                
                return `
                    <div class="file-item ${item.isDirectory ? 'folder' : 'file'}" 
                         onclick="${item.isDirectory ? `navigateToPath('${item.path}')` : `selectFile('${item.path}', '${item.name}')`}">
                        <div class="file-icon">${icon}</div>
                        <div class="file-info">
                            <div class="file-name">${item.name}</div>
                            <div class="file-details">${size} ${date}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Get appropriate icon for file
        function getFileIcon(item) {
            if (item.isDirectory) return 'üìÅ';
            
            const ext = item.name.toLowerCase().split('.').pop();
            const icons = {
                'db': 'üóÑÔ∏è',
                'pdx': 'üìä',
                'px': 'üìä',
                'fdb': 'üî•',
                'gdb': 'üî•',
                'sql': 'üìù',
                'txt': 'üìÑ',
                'csv': 'üìà',
                'xls': 'üìä',
                'xlsx': 'üìä'
            };
            
            return icons[ext] || 'üìÑ';
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Select file
        function selectFile(path, name) {
            selectedFile = path;
            
            // Update UI
            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            event.currentTarget.classList.add('selected');
            
            document.getElementById('selectedFileInfo').textContent = `Selecionado: ${name}`;
            document.getElementById('selectFileButton').disabled = false;
        }

        // Navigation functions
        function navigateBack() {
            if (fileExplorerHistoryIndex > 0) {
                fileExplorerHistoryIndex--;
                const path = fileExplorerHistory[fileExplorerHistoryIndex];
                navigateToPath(path);
            }
        }

        function navigateForward() {
            if (fileExplorerHistoryIndex < fileExplorerHistory.length - 1) {
                fileExplorerHistoryIndex++;
                const path = fileExplorerHistory[fileExplorerHistoryIndex];
                navigateToPath(path);
            }
        }

        function navigateUp() {
            const pathParts = currentPath.replace(/[\\\/]+$/, '').split(/[\\\/]/);
            if (pathParts.length > 1) {
                pathParts.pop();
                const parentPath = pathParts.join('\\') + '\\';
                navigateToPath(parentPath);
            }
        }

        function refreshCurrentPath() {
            navigateToPath(currentPath);
        }

        function updateNavigationButtons() {
            document.getElementById('backButton').disabled = fileExplorerHistoryIndex <= 0;
            document.getElementById('forwardButton').disabled = fileExplorerHistoryIndex >= fileExplorerHistory.length - 1;
        }

        // Select current file and close explorer
        function selectCurrentFile() {
            if (!selectedFile) return;
            
            if (currentExplorerType === 'source') {
                document.getElementById('sourcePath').value = selectedFile;
                addToRecentFiles('source', selectedFile);
            } else {
                document.getElementById('targetDatabase').value = selectedFile;
                addToRecentFiles('target', selectedFile);
            }
            
            closeFileExplorer();
            showStatus(`Arquivo selecionado: ${selectedFile}`, 'success');
        }

        // Close file explorer
        function closeFileExplorer() {
            const modal = document.getElementById('fileExplorerModal');
            if (modal) {
                modal.remove();
            }
            
            // Reset state
            currentExplorerType = '';
            currentPath = '';
            selectedFile = '';
            fileExplorerHistory = [];
            fileExplorerHistoryIndex = -1;
        }

        // Recent files management
        function loadRecentFiles() {
            const sourceFiles = JSON.parse(localStorage.getItem('recentSourceFiles') || '[]');
            const targetFiles = JSON.parse(localStorage.getItem('recentTargetFiles') || '[]');
            
            displayRecentFiles('source', sourceFiles);
            displayRecentFiles('target', targetFiles);
        }

        function displayRecentFiles(type, files) {
            const containerId = type === 'source' ? 'recentSourceFiles' : 'recentTargetFiles';
            const container = document.getElementById(containerId);
            
            if (!container) return;
            
            // Filtrar arquivos por tipo se for origem
            let filteredFiles = files;
            if (type === 'source') {
                const selectedType = document.getElementById('sourceType')?.value || 'paradox';
                filteredFiles = files.filter(file => {
                    const detectedType = detectDatabaseType(file.path);
                    return detectedType === selectedType || detectedType === 'unknown';
                });
            }
            
            if (filteredFiles.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: #6c757d; font-size: 0.85rem;">Nenhum arquivo recente</div>';
                return;
            }
            
            container.innerHTML = filteredFiles.slice(0, 5).map(file => {
                const date = new Date(file.lastUsed).toLocaleDateString('pt-BR');
                const fileName = file.path.split(/[\\\/]/).pop();
                const fileType = type === 'source' ? detectDatabaseType(file.path) : 'firebird';
                const typeIcon = fileType === 'sqlite' ? 'üóÉÔ∏è' : fileType === 'paradox' ? 'üìä' : 'üî•';
                
                return `
                    <div class="recent-file-item" onclick="selectRecentFile('${type}', '${file.path}')">
                        <div class="recent-file-path" title="${file.path}">
                            ${typeIcon} ${fileName}
                        </div>
                        <div class="recent-file-date">${date}</div>
                    </div>
                `;
            }).join('');
        }

        function selectRecentFile(type, path) {
            if (type === 'source') {
                document.getElementById('sourcePath').value = path;
            } else {
                document.getElementById('targetDatabase').value = path;
            }
            
            showStatus(`Arquivo selecionado: ${path}`, 'success');
        }

        function addToRecentFiles(type, path) {
            const storageKey = type === 'source' ? 'recentSourceFiles' : 'recentTargetFiles';
            let recentFiles = JSON.parse(localStorage.getItem(storageKey) || '[]');
            
            // Remove if already exists
            recentFiles = recentFiles.filter(file => file.path !== path);
            
            // Add to beginning
            recentFiles.unshift({
                path: path,
                lastUsed: new Date().toISOString()
            });
            
            // Keep only last 10
            recentFiles = recentFiles.slice(0, 10);
            
            localStorage.setItem(storageKey, JSON.stringify(recentFiles));
            displayRecentFiles(type, recentFiles);
        }

        // Alias para compatibilidade
        function saveRecentFile(type, path) {
            return addToRecentFiles(type, path);
        }

        // ============ END FILE EXPLORER FUNCTIONS ============

        // ============ DATABASE SELECTION DIALOGS ============

        // Show database selection dialog - vers√£o melhorada
        function showDatabaseSelectionDialog(type, databases, sourceType = 'paradox') {
            const dialog = document.createElement('div');
            dialog.className = 'file-explorer-modal';
            dialog.id = 'databaseSelectionModal';
            
            // Determinar t√≠tulo baseado no tipo
            let title, icon, typeLabel;
            if (type === 'source') {
                if (sourceType === 'sqlite') {
                    title = 'üóÉÔ∏è Bancos SQLite Encontrados';
                    icon = 'üóÉÔ∏è';
                    typeLabel = 'SQLite';
                } else {
                    title = 'üìä Bancos Paradox Encontrados';
                    icon = 'üìä';
                    typeLabel = 'Paradox';
                }
            } else {
                title = 'üî• Bancos Firebird Encontrados';
                icon = 'üî•';
                typeLabel = 'Firebird';
            }
            
            dialog.innerHTML = `
                <div class="file-explorer-content" style="max-width: 900px;">
                    <div class="file-explorer-header">
                        <div class="file-explorer-title">${title}</div>
                        <button class="close-explorer" onclick="closeDatabaseSelectionDialog()">√ó</button>
                    </div>
                    
                    <div class="file-explorer-body" style="max-height: 500px;">
                        <div style="margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; color: #1976d2;">
                            <strong>${icon} ${databases.length} banco(s) ${typeLabel} encontrado(s)</strong><br>
                            Selecione o banco que deseja usar para a migra√ß√£o:
                        </div>
                        
                        <div class="database-list">
                            ${databases.map((db, index) => `
                                <div class="database-item" onclick="selectDatabase('${type}', '${db.path}', ${index})">
                                    <div class="database-icon">${getFileIcon({name: db.name, isDirectory: false})}</div>
                                    <div class="database-info">
                                        <div class="database-name">${db.name}</div>
                                        <div class="database-path">${db.path}</div>
                                        <div class="database-details">
                                            <span class="database-size">${formatFileSize(db.size)}</span>
                                            <span class="database-date">Modificado: ${new Date(db.modified).toLocaleDateString('pt-BR')}</span>
                                            <span class="database-type">Tipo: ${db.type || typeLabel}</span>
                                        </div>
                                    </div>
                                    <div class="database-actions">
                                        <button class="btn btn-sm" onclick="event.stopPropagation(); selectDatabase('${type}', '${db.path}', ${index})">
                                            ‚úÖ Selecionar
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="file-explorer-footer">
                        <div class="selected-file-info">
                            üí° Dica: Clique em um banco para selecion√°-lo automaticamente
                        </div>
                        <div class="explorer-actions">
                            <button class="btn btn-secondary" onclick="showAdvancedSearchDialog('${type}')">üîç Busca Avan√ßada</button>
                            <button class="btn btn-secondary" onclick="closeDatabaseSelectionDialog()">Cancelar</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }

        // Select database from dialog
        function selectDatabase(type, path, index) {
            if (type === 'source') {
                document.getElementById('sourcePath').value = path;
                addToRecentFiles('source', path);
            } else {
                document.getElementById('targetDatabase').value = path;
                addToRecentFiles('target', path);
            }
            
            closeDatabaseSelectionDialog();
            showStatus(`‚úÖ Banco selecionado: ${path}`, 'success');
        }

        // Close database selection dialog
        function closeDatabaseSelectionDialog() {
            const modal = document.getElementById('databaseSelectionModal');
            if (modal) {
                modal.remove();
            }
        }

        // Show advanced search dialog
        function showAdvancedSearchDialog(type) {
            closeDatabaseSelectionDialog();
            
            const dialog = document.createElement('div');
            dialog.className = 'file-explorer-modal';
            dialog.id = 'advancedSearchModal';
            
            const title = type === 'source' ? 'üîç Busca Avan√ßada - Bancos Paradox' : 'üîç Busca Avan√ßada - Bancos Firebird';
            const extensions = type === 'source' ? '.db, .pdx, .px, .dbf' : '.fdb, .gdb';
            
            dialog.innerHTML = `
                <div class="file-explorer-content">
                    <div class="file-explorer-header">
                        <div class="file-explorer-title">${title}</div>
                        <button class="close-explorer" onclick="closeAdvancedSearchDialog()">√ó</button>
                    </div>
                    
                    <div class="file-explorer-body">
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 10px; font-weight: 600;">
                                üìÅ Caminhos para Busca (um por linha):
                            </label>
                            <textarea id="searchPaths" style="width: 100%; height: 150px; padding: 10px; border: 1px solid #ddd; border-radius: 6px;" 
                                      placeholder="C:\\dados&#10;C:\\sistema&#10;C:\\Program Files&#10;D:\\&#10;E:\\">C:\\dados
C:\\sistema
C:\\Program Files
C:\\Users\\Public\\Documents
D:\\
E:\\</textarea>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 10px; font-weight: 600;">
                                ‚öôÔ∏è Op√ß√µes de Busca:
                            </label>
                            <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="includeSubdirs" checked>
                                    Incluir subdiret√≥rios
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="caseSensitive">
                                    Busca sens√≠vel a mai√∫sculas
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="hiddenFiles">
                                    Incluir arquivos ocultos
                                </label>
                            </div>
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <strong>üìã Tipos de arquivo suportados:</strong><br>
                            ${extensions}
                        </div>
                        
                        <div id="searchResults" style="max-height: 200px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 6px; padding: 10px; background: white;">
                            <div style="text-align: center; color: #6c757d;">
                                Clique em "Iniciar Busca" para encontrar bancos
                            </div>
                        </div>
                    </div>
                    
                    <div class="file-explorer-footer">
                        <div class="selected-file-info">
                            üîç Configure os caminhos e inicie a busca avan√ßada
                        </div>
                        <div class="explorer-actions">
                            <button class="btn btn-secondary" onclick="closeAdvancedSearchDialog()">Cancelar</button>
                            <button class="btn" onclick="startAdvancedSearch('${type}')">üöÄ Iniciar Busca</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }

        // Start advanced search
        async function startAdvancedSearch(type) {
            const searchPaths = document.getElementById('searchPaths').value
                .split('\n')
                .map(path => path.trim())
                .filter(path => path.length > 0);
            
            const resultsContainer = document.getElementById('searchResults');
            resultsContainer.innerHTML = '<div style="text-align: center; color: #667eea;">üîç Buscando...</div>';
            
            try {
                const response = await fetch('/api/auto-detect-enhanced', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        type: type,
                        searchPaths: searchPaths,
                        options: {
                            includeSubdirs: document.getElementById('includeSubdirs').checked,
                            caseSensitive: document.getElementById('caseSensitive').checked,
                            hiddenFiles: document.getElementById('hiddenFiles').checked
                        }
                    })
                });

                const result = await response.json();
                
                if (result.success && result.databases.length > 0) {
                    displayAdvancedSearchResults(type, result.databases);
                } else {
                    resultsContainer.innerHTML = `
                        <div style="text-align: center; color: #dc3545;">
                            ‚ùå Nenhum banco encontrado nos caminhos especificados
                        </div>
                    `;
                }
            } catch (error) {
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #dc3545;">
                        ‚ùå Erro na busca: ${error.message}
                    </div>
                `;
            }
        }

        // Display advanced search results
        function displayAdvancedSearchResults(type, databases) {
            const resultsContainer = document.getElementById('searchResults');
            
            resultsContainer.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: 600; color: #28a745;">
                    ‚úÖ ${databases.length} banco(s) encontrado(s):
                </div>
                ${databases.map(db => `
                    <div class="search-result-item" onclick="selectDatabaseFromSearch('${type}', '${db.path}')" 
                         style="padding: 8px; border: 1px solid #e9ecef; border-radius: 4px; margin-bottom: 5px; cursor: pointer; transition: all 0.3s ease;">
                        <div style="font-weight: 500;">${getFileIcon({name: db.name, isDirectory: false})} ${db.name}</div>
                        <div style="font-size: 0.85rem; color: #6c757d;">${db.path}</div>
                        <div style="font-size: 0.75rem; color: #adb5bd;">${formatFileSize(db.size)} ‚Ä¢ ${new Date(db.modified).toLocaleDateString('pt-BR')}</div>
                    </div>
                `).join('')}
            `;
            
            // Add hover effects
            document.querySelectorAll('.search-result-item').forEach(item => {
                item.addEventListener('mouseenter', function() {
                    this.style.background = '#f8f9fa';
                    this.style.borderColor = '#667eea';
                });
                item.addEventListener('mouseleave', function() {
                    this.style.background = 'white';
                    this.style.borderColor = '#e9ecef';
                });
            });
        }

        // Select database from advanced search
        function selectDatabaseFromSearch(type, path) {
            if (type === 'source') {
                document.getElementById('sourcePath').value = path;
                addToRecentFiles('source', path);
            } else {
                document.getElementById('targetDatabase').value = path;
                addToRecentFiles('target', path);
            }
            
            closeAdvancedSearchDialog();
            showStatus(`‚úÖ Banco selecionado: ${path}`, 'success');
        }

        // Close advanced search dialog
        function closeAdvancedSearchDialog() {
            const modal = document.getElementById('advancedSearchModal');
            if (modal) {
                modal.remove();
            }
        }

        // ============ END DATABASE SELECTION DIALOGS ============

        // Mostrar status
        // ==================== SISTEMA DE MAPEAMENTO DE COLUNAS ====================

        // Atualizar status visual das tabelas
        function updateTableVisualStatus() {
            // Atualizar tabelas de origem
            document.querySelectorAll('#sourceTablesList .table-item').forEach(tableElement => {
                const tableName = tableElement.querySelector('.table-name').textContent;
                const mapping = tableMappings.find(m => m.sourceTable === tableName);
                
                tableElement.classList.remove('mapped', 'partially-mapped', 'validated');
                
                if (mapping) {
                    const mappedColumnsCount = mapping.columnMappings ? mapping.columnMappings.length : 0;
                    const totalColumns = mapping.sourceColumns ? mapping.sourceColumns.length : 0;
                    
                    // Verificar se est√° validado (prioridade m√°xima)
                    if (mapping.validated) {
                        tableElement.classList.add('validated');
                    } else if (mappedColumnsCount === totalColumns && mappedColumnsCount > 0) {
                        tableElement.classList.add('mapped');
                    } else if (mappedColumnsCount > 0) {
                        tableElement.classList.add('partially-mapped');
                    }
                }
            });

            // Atualizar tabelas de destino
            document.querySelectorAll('#targetTablesList .table-item').forEach(tableElement => {
                const tableName = tableElement.querySelector('.table-name').textContent;
                const mapping = tableMappings.find(m => m.targetTable === tableName);
                
                tableElement.classList.remove('mapped', 'partially-mapped', 'validated');
                
                if (mapping) {
                    const mappedColumnsCount = mapping.columnMappings ? mapping.columnMappings.length : 0;
                    const totalColumns = mapping.targetColumns ? mapping.targetColumns.length : 0;
                    
                    // Verificar se est√° validado (prioridade m√°xima)
                    if (mapping.validated) {
                        tableElement.classList.add('validated');
                    } else if (mappedColumnsCount === totalColumns && mappedColumnsCount > 0) {
                        tableElement.classList.add('mapped');
                    } else if (mappedColumnsCount > 0) {
                        tableElement.classList.add('partially-mapped');
                    }
                }
            });
        }

        // Editar mapeamento de colunas
        function editColumnMapping(mappingId) {
            const mapping = tableMappings.find(m => (m.id || m.sourceTable) === mappingId);
            if (!mapping) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            currentMapping = mapping;
            
            // Garantir que as arrays de colunas e mapeamentos est√£o limpos
            sourceColumns = [...(mapping.sourceColumns || [])];
            targetColumns = [...(mapping.targetColumns || [])];
            columnMappings = [...(mapping.columnMappings || [])];

            // Atualizar interface
            document.getElementById('currentMappingInfo').textContent = 
                `${mapping.sourceTable} ‚Üí ${mapping.targetTable}`;
            
            renderColumnLists();
            updateColumnMappingStats();
            
            // Mostrar interface
            document.getElementById('columnMappingInterface').style.display = 'block';
            
            // Scroll suave para a interface
            document.getElementById('columnMappingInterface').scrollIntoView({ 
                behavior: 'smooth' 
            });
            
            // Log para debug
            console.log('üìã Editando mapeamento:', {
                sourceTable: mapping.sourceTable,
                targetTable: mapping.targetTable,
                sourceColumns: sourceColumns.length,
                targetColumns: targetColumns.length,
                columnMappings: columnMappings.length
            });
        }

        // Renderizar listas de colunas
        function renderColumnLists() {
            renderSourceColumns();
            renderTargetColumns();
        }

        // Renderizar colunas de origem
        function renderSourceColumns() {
            const container = document.getElementById('sourceColumnsList');
            container.innerHTML = '';

            sourceColumns.forEach(column => {
                const isMapped = columnMappings.some(mapping => mapping.sourceColumn === column.name);
                
                const columnElement = document.createElement('div');
                columnElement.className = `column-item ${isMapped ? 'mapped' : ''}`;
                columnElement.draggable = true;
                columnElement.dataset.columnName = column.name;
                columnElement.dataset.columnType = column.type;

                columnElement.innerHTML = `
                    <div class="column-name">${column.name}</div>
                    <div class="column-type">${column.type}</div>
                `;

                // Eventos de drag and drop
                columnElement.addEventListener('dragstart', (e) => {
                    draggedColumn = {
                        name: column.name,
                        type: column.type,
                        source: 'source'
                    };
                    columnElement.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', JSON.stringify(draggedColumn));
                });

                columnElement.addEventListener('dragend', () => {
                    columnElement.classList.remove('dragging');
                    draggedColumn = null;
                });

                container.appendChild(columnElement);
            });
        }

        // Renderizar colunas de destino
        function renderTargetColumns() {
            const container = document.getElementById('targetColumnsList');
            container.innerHTML = '';

            targetColumns.forEach(column => {
                const isMapped = columnMappings.some(mapping => mapping.targetColumn === column.name);
                
                const columnElement = document.createElement('div');
                columnElement.className = `column-item ${isMapped ? 'mapped' : ''}`;
                columnElement.dataset.columnName = column.name;
                columnElement.dataset.columnType = column.type;

                columnElement.innerHTML = `
                    <div class="column-name">${column.name}</div>
                    <div class="column-type">${column.type}</div>
                `;

                // Eventos de drag and drop
                columnElement.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    columnElement.classList.add('drag-over');
                });

                columnElement.addEventListener('dragleave', () => {
                    columnElement.classList.remove('drag-over');
                });

                columnElement.addEventListener('drop', (e) => {
                    e.preventDefault();
                    columnElement.classList.remove('drag-over');
                    
                    const sourceColumnData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    if (sourceColumnData && sourceColumnData.source === 'source') {
                        createColumnMapping(sourceColumnData.name, column.name);
                    }
                });

                container.appendChild(columnElement);
            });
        }

        // Criar mapeamento de coluna
        function createColumnMapping(sourceColumnName, targetColumnName) {
            // Verificar se as colunas pertencem √†s tabelas atuais
            const sourceColumn = sourceColumns.find(c => c.name === sourceColumnName);
            const targetColumn = targetColumns.find(c => c.name === targetColumnName);

            if (!sourceColumn || !targetColumn) {
                showStatus('‚ùå Informa√ß√µes das colunas n√£o encontradas', 'error');
                return;
            }

            // Verificar se mapeamento j√° existe apenas para as mesmas tabelas
            const existingMapping = columnMappings.find(m => 
                (m.sourceColumn === sourceColumnName && m.sourceTable === currentMapping.sourceTable) ||
                (m.targetColumn === targetColumnName && m.targetTable === currentMapping.targetTable)
            );

            if (existingMapping) {
                // Se for o mesmo mapeamento, permitir sobrescrever
                if (existingMapping.sourceColumn === sourceColumnName && existingMapping.targetColumn === targetColumnName) {
                    showStatus(`üîÑ Atualizando mapeamento existente: ${sourceColumnName} ‚Üí ${targetColumnName}`, 'info');
                } else {
                    // Se for conflito real, mostrar op√ß√£o de substituir
                    const replaceConfirm = confirm(
                        `‚ö†Ô∏è Coluna j√° mapeada:\n` +
                        `Atual: ${existingMapping.sourceColumn} ‚Üí ${existingMapping.targetColumn}\n` +
                        `Novo: ${sourceColumnName} ‚Üí ${targetColumnName}\n\n` +
                        `Deseja substituir o mapeamento existente?`
                    );
                    
                    if (!replaceConfirm) {
                        return;
                    }
                    
                    // Remover mapeamento existente
                    const index = columnMappings.findIndex(m => m === existingMapping);
                    if (index !== -1) {
                        columnMappings.splice(index, 1);
                    }
                }
            }

            // Criar ou atualizar mapeamento
            const compatibilityInfo = typesAreCompatible(sourceColumn.type, targetColumn.type);
            const newMapping = {
                sourceColumn: sourceColumnName,
                targetColumn: targetColumnName,
                sourceType: sourceColumn.type,
                targetType: targetColumn.type,
                sourceTable: currentMapping.sourceTable,
                targetTable: currentMapping.targetTable,
                compatible: compatibilityInfo.compatible,
                requiresConversion: compatibilityInfo.requiresConversion,
                conversionType: compatibilityInfo.conversionType,
                confidence: calculateColumnCompatibility(sourceColumn, targetColumn)
            };

            // Verificar se j√° existe e substituir, ou adicionar novo
            const existingIndex = columnMappings.findIndex(m => 
                m.sourceColumn === sourceColumnName && m.targetColumn === targetColumnName
            );

            if (existingIndex !== -1) {
                columnMappings[existingIndex] = newMapping;
                showStatus(`üîÑ Mapeamento atualizado: ${sourceColumnName} ‚Üí ${targetColumnName}`, 'success');
            } else {
                columnMappings.push(newMapping);
                showStatus(`‚úÖ Mapeamento criado: ${sourceColumnName} ‚Üí ${targetColumnName}`, 'success');
            }
            
            // Atualizar interface
            renderColumnLists();
            updateColumnMappingStats();
        }

        // Calcular compatibilidade entre colunas
        function calculateColumnCompatibility(sourceColumn, targetColumn) {
            let score = 0.5; // Score base
            
            // Bonus por nome similar
            if (sourceColumn.name.toLowerCase() === targetColumn.name.toLowerCase()) {
                score += 0.3;
            } else if (sourceColumn.name.toLowerCase().includes(targetColumn.name.toLowerCase()) ||
                      targetColumn.name.toLowerCase().includes(sourceColumn.name.toLowerCase())) {
                score += 0.2;
            }
            
            // Bonus por tipo compat√≠vel
            if (sourceColumn.type === targetColumn.type) {
                score += 0.2;
            } else {
                const compatibilityInfo = typesAreCompatible(sourceColumn.type, targetColumn.type);
                if (compatibilityInfo.compatible) {
                    score += compatibilityInfo.requiresConversion ? 0.05 : 0.1;
                }
            }
            
            return Math.min(score, 1.0);
        }

        // Verificar se tipos s√£o compat√≠veis
        function typesAreCompatible(sourceType, targetType) {
            // NOVA FUNCIONALIDADE: Permite convers√£o entre qualquer tipo durante a migra√ß√£o
            // O sistema sempre retorna true, indicando que convers√£o ser√° feita automaticamente
            
            // Normalizar tipos removendo par√¢metros de tamanho
            function normalizeType(type) {
                if (!type) return '';
                return type.toUpperCase()
                    .replace(/\(\d+\)/g, '') // Remove (20), (255), etc.
                    .replace(/\(\d+,\d+\)/g, '') // Remove (18,2), etc.
                    .replace(/FB_TYPE_\d+/g, match => {
                        // Converter c√≥digos FB_TYPE para tipos conhecidos
                        const typeNum = match.match(/\d+/)?.[0];
                        switch(typeNum) {
                            case '8': return 'INTEGER';
                            case '12': return 'DATE';
                            case '37': return 'VARCHAR';
                            default: return 'VARCHAR'; // Fallback seguro
                        }
                    })
                    .trim();
            }

            const sourceNorm = normalizeType(sourceType);
            const targetNorm = normalizeType(targetType);
            
            // SEMPRE permite o mapeamento - convers√£o ser√° feita na migra√ß√£o
            return {
                compatible: true,
                requiresConversion: sourceNorm !== targetNorm,
                conversionType: getConversionType(sourceNorm, targetNorm)
            };
        }
        
        function getConversionType(sourceType, targetType) {
            // Define o tipo de convers√£o necess√°ria
            const textTypes = ['TEXT', 'VARCHAR', 'CHAR', 'STRING', 'CSTRING'];
            const numberTypes = ['INTEGER', 'BIGINT', 'SMALLINT', 'NUMERIC', 'REAL', 'DOUBLE', 'FLOAT'];
            const dateTypes = ['DATE', 'TIMESTAMP', 'DATETIME', 'TIME'];
            
            if (sourceType === targetType) return 'DIRECT';
            
            // Texto para Data/Hora
            if (textTypes.includes(sourceType) && dateTypes.includes(targetType)) {
                return 'TEXT_TO_DATE';
            }
            
            // Texto para N√∫mero
            if (textTypes.includes(sourceType) && numberTypes.includes(targetType)) {
                return 'TEXT_TO_NUMBER';
            }
            
            // N√∫mero para Texto
            if (numberTypes.includes(sourceType) && textTypes.includes(targetType)) {
                return 'NUMBER_TO_TEXT';
            }
            
            // Data para Texto
            if (dateTypes.includes(sourceType) && textTypes.includes(targetType)) {
                return 'DATE_TO_TEXT';
            }
            
            // Entre tipos num√©ricos
            if (numberTypes.includes(sourceType) && numberTypes.includes(targetType)) {
                return 'NUMBER_TO_NUMBER';
            }
            
            // Entre tipos de texto
            if (textTypes.includes(sourceType) && textTypes.includes(targetType)) {
                return 'TEXT_TO_TEXT';
            }
            
            return 'CUSTOM_CONVERSION';
            
            return false;
        }

        // Obter convers√£o inteligente de tipos
        function getTypeConversion(sourceType, targetType) {
            const sourceUpper = sourceType?.toUpperCase();
            const targetUpper = targetType?.toUpperCase();
            
            // Mapeamentos de convers√£o espec√≠ficos
            const conversionMap = {
                // Convers√µes de TEXT para outros tipos
                'TEXT->DATE': { 
                    converted: 'DATE', 
                    note: 'Texto ser√° convertido para data',
                    icon: 'üìÖ',
                    example: '"2023-12-25" ‚Üí 2023-12-25'
                },
                'TEXT->TIMESTAMP': { 
                    converted: 'TIMESTAMP', 
                    note: 'Texto ser√° convertido para timestamp',
                    icon: '‚è∞',
                    example: '"2023-12-25 10:30" ‚Üí 2023-12-25 10:30:00'
                },
                'TEXT->INTEGER': { 
                    converted: 'INTEGER', 
                    note: 'Texto num√©rico ser√° convertido para inteiro',
                    icon: 'üî¢',
                    example: '"123" ‚Üí 123'
                },
                'TEXT->NUMERIC': { 
                    converted: 'NUMERIC', 
                    note: 'Texto num√©rico ser√° convertido para decimal',
                    icon: 'üî¢',
                    example: '"123.45" ‚Üí 123.45'
                },
                
                // Convers√µes de VARCHAR para outros tipos
                'VARCHAR->DATE': { 
                    converted: 'DATE', 
                    note: 'Varchar ser√° convertido para data',
                    icon: 'üìÖ',
                    example: '"25/12/2023" ‚Üí 2023-12-25'
                },
                'VARCHAR->TIMESTAMP': { 
                    converted: 'TIMESTAMP', 
                    note: 'Varchar ser√° convertido para timestamp',
                    icon: '‚è∞',
                    example: '"25/12/2023 10:30" ‚Üí 2023-12-25 10:30:00'
                },
                
                // Convers√µes num√©ricas
                'INTEGER->BIGINT': { 
                    converted: 'BIGINT', 
                    note: 'Inteiro ser√° expandido para bigint',
                    icon: 'üìà',
                    example: '123 ‚Üí 123 (maior capacidade)'
                },
                'INTEGER->NUMERIC': { 
                    converted: 'NUMERIC', 
                    note: 'Inteiro ser√° convertido para decimal',
                    icon: 'üî¢',
                    example: '123 ‚Üí 123.00'
                },
                'REAL->DOUBLE': { 
                    converted: 'DOUBLE', 
                    note: 'Real ser√° expandido para double precision',
                    icon: 'üìè',
                    example: '123.45 ‚Üí 123.45 (maior precis√£o)'
                },
                
                // Convers√µes de data
                'DATE->TIMESTAMP': { 
                    converted: 'TIMESTAMP', 
                    note: 'Data ser√° expandida para timestamp',
                    icon: '‚è∞',
                    example: '2023-12-25 ‚Üí 2023-12-25 00:00:00'
                },
                'TIMESTAMP->DATE': { 
                    converted: 'DATE', 
                    note: 'Timestamp ser√° truncado para data',
                    icon: 'üìÖ',
                    example: '2023-12-25 10:30:00 ‚Üí 2023-12-25'
                }
            };
            
            const conversionKey = `${sourceUpper}->${targetUpper}`;
            
            if (conversionMap[conversionKey]) {
                return conversionMap[conversionKey];
            }
            
            // Se os tipos s√£o iguais, sem convers√£o
            if (sourceUpper === targetUpper) {
                return {
                    converted: targetType,
                    note: 'Tipo id√™ntico - sem convers√£o necess√°ria',
                    icon: '‚úÖ',
                    example: `${sourceType} ‚Üí ${targetType}`
                };
            }
            
            // Convers√£o gen√©rica se compat√≠vel
            const compatibilityInfo = typesAreCompatible(sourceType, targetType);
            if (compatibilityInfo.compatible) {
                return {
                    converted: targetType,
                    note: `${sourceType} ser√° convertido para ${targetType}`,
                    icon: 'üîÑ',
                    example: `${sourceType} ‚Üí ${targetType}`
                };
            }
            
            // Convers√£o com aviso se incompat√≠vel
            return {
                converted: targetType,
                note: `‚ö†Ô∏è Convers√£o pode causar perda de dados`,
                icon: '‚ö†Ô∏è',
                example: `${sourceType} ‚Üí ${targetType} (verificar dados)`
            };
        }

        // Formatar exibi√ß√£o de tipo com convers√£o - Layout Compacto
        function formatTypeWithConversion(sourceType, targetType) {
            if (!sourceType || !targetType) {
                return `<span class="type-display">${sourceType || targetType || 'N/A'}</span>`;
            }
            
            const compatibilityInfo = typesAreCompatible(sourceType, targetType);
            
            if (sourceType?.toUpperCase() === targetType?.toUpperCase()) {
                return `<span class="type-display same-type">‚úì ${sourceType}</span>`;
            }
            
            // Determinar √≠cone de convers√£o baseado no tipo
            let conversionIcon = 'üîÑ'; // Default
            switch (compatibilityInfo.conversionType) {
                case 'TEXT_TO_DATE':
                    conversionIcon = 'üìÖ';
                    break;
                case 'TEXT_TO_NUMBER':
                    conversionIcon = 'üî¢';
                    break;
                case 'NUMBER_TO_TEXT':
                    conversionIcon = 'üî§';
                    break;
                case 'DATE_TO_TEXT':
                    conversionIcon = 'üìù';
                    break;
                case 'NUMBER_TO_NUMBER':
                    conversionIcon = 'üìä';
                    break;
                case 'TEXT_TO_TEXT':
                    conversionIcon = '‚úèÔ∏è';
                    break;
                case 'DIRECT':
                    conversionIcon = '‚úÖ';
                    break;
                default:
                    conversionIcon = '‚ö°';
            }
            
            return `
                <div class="type-conversion compact" title="Convers√£o autom√°tica: ${compatibilityInfo.conversionType}">
                    <span class="source-type">${sourceType}</span>
                    <span class="conversion-arrow">${conversionIcon}</span>
                    <span class="target-type">${targetType}</span>
                </div>
            `;
        }

        // Auto-mapear colunas
        function autoMapColumns() {
            if (!currentMapping) {
                showStatus('‚ùå Nenhum mapeamento selecionado', 'error');
                return;
            }

            const newMappings = [];
            
            sourceColumns.forEach(sourceColumn => {
                // Pular se j√° mapeada
                if (columnMappings.some(m => m.sourceColumn === sourceColumn.name)) {
                    return;
                }

                // Procurar melhor match
                let bestMatch = null;
                let bestScore = 0;

                targetColumns.forEach(targetColumn => {
                    // Pular se j√° mapeada
                    if (columnMappings.some(m => m.targetColumn === targetColumn.name)) {
                        return;
                    }

                    const score = calculateColumnCompatibility(sourceColumn, targetColumn);
                    if (score > bestScore && score >= 0.6) { // Threshold m√≠nimo
                        bestScore = score;
                        bestMatch = targetColumn;
                    }
                });

                if (bestMatch) {
                    const compatibilityInfo = typesAreCompatible(sourceColumn.type, bestMatch.type);
                    newMappings.push({
                        sourceColumn: sourceColumn.name,
                        targetColumn: bestMatch.name,
                        sourceType: sourceColumn.type,
                        targetType: bestMatch.type,
                        compatible: compatibilityInfo.compatible,
                        requiresConversion: compatibilityInfo.requiresConversion,
                        conversionType: compatibilityInfo.conversionType,
                        confidence: bestScore
                    });
                }
            });

            columnMappings.push(...newMappings);
            renderColumnLists();
            updateColumnMappingStats();
            
            showStatus(`ü§ñ Auto-mapeamento conclu√≠do: ${newMappings.length} colunas mapeadas`, 'success');
        }

        // Limpar mapeamentos de colunas
        function clearColumnMappings() {
            columnMappings = [];
            renderColumnLists();
            updateColumnMappingStats();
            showStatus('üóëÔ∏è Mapeamentos de colunas removidos', 'info');
        }

        // Atualizar estat√≠sticas do mapeamento
        function updateColumnMappingStats() {
            const mappedCount = columnMappings.length;
            const unmappedSourceCount = sourceColumns.length - mappedCount;
            const unmappedTargetCount = targetColumns.length - mappedCount;
            const completeness = sourceColumns.length > 0 ? 
                Math.round((mappedCount / sourceColumns.length) * 100) : 0;

            document.getElementById('mappedColumnsCount').textContent = mappedCount;
            document.getElementById('unmappedSourceCount').textContent = unmappedSourceCount;
            document.getElementById('unmappedTargetCount').textContent = unmappedTargetCount;
            document.getElementById('mappingCompleteness').textContent = completeness + '%';
        }

        // Salvar altera√ß√µes no mapeamento
        function saveMappingChanges() {
            if (!currentMapping) {
                showStatus('‚ùå Nenhum mapeamento selecionado', 'error');
                return;
            }

            // Atualizar mapeamento atual
            currentMapping.columnMappings = [...columnMappings];
            currentMapping.sourceColumns = [...sourceColumns];
            currentMapping.targetColumns = [...targetColumns];
            
            // Recalcular confian√ßa baseada nos mapeamentos de colunas
            const avgConfidence = columnMappings.length > 0 ?
                columnMappings.reduce((sum, mapping) => sum + mapping.confidence, 0) / columnMappings.length :
                0;
            currentMapping.confidence = Math.round(avgConfidence * 100);

            // Atualizar no array global se necess√°rio
            const mappingIndex = tableMappings.findIndex(m => 
                (m.id || m.sourceTable) === (currentMapping.id || currentMapping.sourceTable)
            );
            if (mappingIndex !== -1) {
                tableMappings[mappingIndex] = { ...currentMapping };
            }

            // Atualizar interface
            updateAllMappingViews();
            
            // Fechar interface de edi√ß√£o de colunas
            closeColumnMapping();
            
            showStatus('üíæ Mapeamento salvo e fechado com sucesso', 'success');
        }

        // Resetar mapeamento
        function resetMapping() {
            if (!currentMapping) {
                showStatus('‚ùå Nenhum mapeamento selecionado', 'error');
                return;
            }

            columnMappings = [];
            renderColumnLists();
            updateColumnMappingStats();
            
            showStatus('üîÑ Mapeamento resetado', 'info');
        }

        // Validar mapeamento
        function validateMapping() {
            if (!currentMapping) {
                showStatus('‚ùå Nenhum mapeamento selecionado', 'error');
                return;
            }

            const errors = [];
            const warnings = [];
            
            // Verificar se h√° colunas obrigat√≥rias n√£o mapeadas
            const requiredColumns = sourceColumns.filter(col => col.nullable === false);
            requiredColumns.forEach(col => {
                if (!columnMappings.some(m => m.sourceColumn === col.name)) {
                    errors.push(`Coluna obrigat√≥ria n√£o mapeada: ${col.name}`);
                }
            });

            // Verificar incompatibilidades de tipo (como avisos, n√£o erros)
            columnMappings.forEach(mapping => {
                if (!mapping.compatible) {
                    warnings.push(`Convers√£o de tipo necess√°ria: ${mapping.sourceColumn} (${mapping.sourceType}) ‚Üí ${mapping.targetColumn} (${mapping.targetType})`);
                }
            });

            // Se n√£o h√° erros cr√≠ticos, permitir valida√ß√£o
            if (errors.length === 0) {
                // Marcar mapeamento como validado
                currentMapping.validated = true;
                currentMapping.validatedAt = new Date().toISOString();
                currentMapping.validatedBy = 'usu√°rio';
                
                // Salvar altera√ß√µes automaticamente
                saveMappingChanges();
                
                // NOVA FUNCIONALIDADE: Transferir para aba de Migra√ß√£o
                transferValidatedMappingToMigration(currentMapping);
                
                // Atualizar interface visual
                updateAllMappingViews();
                
                let message = '‚úÖ Mapeamento validado com sucesso! üöÄ Transferido para aba MIGRA√á√ÉO.';
                if (warnings.length > 0) {
                    message += `\n\n‚ö†Ô∏è ${warnings.length} convers√£o(√µes) de tipo detectada(s), mas o mapeamento foi aceito.`;
                }
                
                // Adicionar instru√ß√µes para continuar
                message += '\n\nüéØ Continue mapeando outras tabelas ou v√° para aba MIGRA√á√ÉO para executar a transfer√™ncia.';
                
                showStatus(message, 'success');
                
                // Log dos avisos no console para refer√™ncia
                if (warnings.length > 0) {
                    console.log('üîÑ Convers√µes de tipo detectadas:', warnings);
                }
                
                // Fechar interface atual para permitir nova sele√ß√£o
                setTimeout(() => {
                    closeColumnMapping();
                    showNextMappingOptions();
                }, 2000);
                
            } else {
                let errorMessage = `‚ùå Problemas cr√≠ticos encontrados (${errors.length}): ${errors.join('; ')}`;
                if (warnings.length > 0) {
                    errorMessage += `\n\n‚ö†Ô∏è Avisos adicionais (${warnings.length}): ${warnings.join('; ')}`;
                }
                showStatus(errorMessage, 'error');
                console.log('üîç Detalhes dos problemas:', { errors, warnings });
            }
        }

        // Mostrar op√ß√µes para pr√≥ximo mapeamento
        function showNextMappingOptions() {
            const validatedCount = tableMappings.filter(m => m.validated).length;
            const totalMappings = tableMappings.length;
            const unvalidatedMappings = tableMappings.filter(m => !m.validated);
            
            if (unvalidatedMappings.length > 0) {
                // Ainda h√° mapeamentos n√£o validados
                showStatus(`üìä Progresso: ${validatedCount}/${totalMappings} mapeamentos validados. ${unvalidatedMappings.length} pendentes.`, 'info');
                
                // Destacar visualmente tabelas n√£o mapeadas
                highlightUnmappedTables();
            } else {
                // Todos os mapeamentos atuais foram validados
                const unmappedSourceTables = getUnmappedTables('source');
                const unmappedTargetTables = getUnmappedTables('target');
                
                if (unmappedSourceTables.length > 0 || unmappedTargetTables.length > 0) {
                    showStatus(`üéâ ${totalMappings} mapeamentos validados! Ainda h√° ${unmappedSourceTables.length + unmappedTargetTables.length} tabelas dispon√≠veis para mapear.`, 'success');
                    highlightUnmappedTables();
                } else {
                    showStatus('üèÜ Parab√©ns! Todas as tabelas foram mapeadas e validadas! Sistema pronto para migra√ß√£o.', 'success');
                }
            }
        }

        // Destacar tabelas n√£o mapeadas
        function highlightUnmappedTables() {
            // Remover highlights anteriores
            document.querySelectorAll('.table-item.highlight-unmapped').forEach(item => {
                item.classList.remove('highlight-unmapped');
            });
            
            // Destacar tabelas n√£o mapeadas
            const unmappedSourceTables = getUnmappedTables('source');
            const unmappedTargetTables = getUnmappedTables('target');
            
            unmappedSourceTables.forEach(tableName => {
                const tableElement = document.querySelector(`#sourceTablesList .table-item[data-table-name="${tableName}"]`);
                if (tableElement) {
                    tableElement.classList.add('highlight-unmapped');
                }
            });
            
            unmappedTargetTables.forEach(tableName => {
                const tableElement = document.querySelector(`#targetTablesList .table-item[data-table-name="${tableName}"]`);
                if (tableElement) {
                    tableElement.classList.add('highlight-unmapped');
                }
            });
        }

        // Atualizar informa√ß√µes de progresso
        function updateMappingProgress() {
            const totalMappings = tableMappings.length;
            const validatedMappings = tableMappings.filter(m => m.validated).length;
            const pendingMappings = totalMappings - validatedMappings;
            
            const mappingStatsElement = document.getElementById('mappingStats');
            const validationStatsElement = document.getElementById('validationStats');
            const currentSelectionElement = document.getElementById('currentSelection');
            const selectionInfoElement = document.getElementById('selectionInfo');
            
            if (mappingStatsElement) {
                if (pendingMappings > 0) {
                    mappingStatsElement.textContent = `üìã ${pendingMappings} mapeamentos pendentes`;
                } else if (totalMappings > 0) {
                    mappingStatsElement.textContent = `‚úÖ Todos os mapeamentos validados`;
                    mappingStatsElement.style.background = '#d4edda';
                    mappingStatsElement.style.color = '#155724';
                } else {
                    mappingStatsElement.textContent = `üìã 0 mapeamentos configurados`;
                    mappingStatsElement.style.background = 'white';
                    mappingStatsElement.style.color = '#495057';
                }
            }
            
            if (validationStatsElement) {
                if (validatedMappings > 0) {
                    validationStatsElement.textContent = `üöÄ ${validatedMappings} na migra√ß√£o`;
                    validationStatsElement.style.background = '#cce7ff';
                    validationStatsElement.style.color = '#0c5460';
                } else {
                    validationStatsElement.textContent = `‚úÖ 0 validados`;
                    validationStatsElement.style.background = 'white';
                    validationStatsElement.style.color = '#495057';
                }
            }
            
            // Mostrar sele√ß√µes atuais
            if (selectedSourceTable || selectedTargetTable) {
                let selectionText = '';
                if (selectedSourceTable && selectedTargetTable) {
                    selectionText = `${selectedSourceTable.name} ‚Üí ${selectedTargetTable.name}`;
                } else if (selectedSourceTable) {
                    selectionText = `üìã ${selectedSourceTable.name} (aguardando destino)`;
                } else if (selectedTargetTable) {
                    selectionText = `üéØ ${selectedTargetTable.name} (aguardando origem)`;
                }
                
                if (selectionInfoElement) {
                    selectionInfoElement.textContent = selectionText;
                }
                if (currentSelectionElement) {
                    currentSelectionElement.style.display = 'flex';
                }
            } else {
                if (currentSelectionElement) {
                    currentSelectionElement.style.display = 'none';
                }
            }
        }

        // Obter tabelas n√£o mapeadas
        function getUnmappedTables(type) {
            const schema = type === 'source' ? sourceSchema : targetSchema;
            const mappedTables = tableMappings.map(m => type === 'source' ? m.sourceTable : m.targetTable);
            
            return schema
                .map(table => table.name)
                .filter(tableName => !mappedTables.includes(tableName));
        }

        // Selecionar mapeamento para edi√ß√£o (usado na sugest√£o)
        function selectMappingForEdit(mapping) {
            if (!mapping) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            // Usar a fun√ß√£o existente de edi√ß√£o
            editColumnMapping(mapping.id || mapping.sourceTable);
            
            // Destacar visualmente o mapeamento selecionado
            setTimeout(() => {
                showStatus(`üéØ Editando relacionamento: ${mapping.sourceTable} ‚Üí ${mapping.targetTable}`, 'info');
            }, 500);
        }

        // Desmarcar valida√ß√£o (para revalidar)
        function unvalidateMapping(mappingId) {
            const mapping = tableMappings.find(m => (m.id || m.sourceTable) === mappingId);
            if (!mapping) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            if (confirm(`üîÑ Deseja remover a valida√ß√£o do relacionamento "${mapping.sourceTable} ‚Üí ${mapping.targetTable}"?\n\nIsso permitir√° que voc√™ fa√ßa nova valida√ß√£o ap√≥s ajustes.`)) {
                mapping.validated = false;
                delete mapping.validatedAt;
                delete mapping.validatedBy;
                
                updateAllMappingViews();
                
                showStatus(`üîÑ Valida√ß√£o removida: ${mapping.sourceTable} ‚Üí ${mapping.targetTable}`, 'info');
            }
        }

        // Fechar interface de mapeamento de colunas
        function closeColumnMapping() {
            document.getElementById('columnMappingInterface').style.display = 'none';
            currentMapping = null;
            sourceColumns = [];
            targetColumns = [];
            columnMappings = [];
        }

        // NOVA FUNCIONALIDADE: Transferir mapeamento validado para aba de Migra√ß√£o
        function transferValidatedMappingToMigration(mapping) {
            console.log('üöÄ INICIANDO transferValidatedMappingToMigration...');
            console.log('üìã Mapeamento recebido:', mapping);
            
            if (!mapping) {
                console.error('‚ùå Nenhum mapeamento fornecido para transfer√™ncia!');
                return;
            }
            
            // Garantir que temos os nomes das tabelas
            const sourceTableName = mapping.sourceTable || mapping.source || 'Tabela de Origem';
            const targetTableName = mapping.targetTable || mapping.target || 'Tabela de Destino';
            
            console.log('üìã Nomes das tabelas extra√≠dos:', {
                sourceTableName,
                targetTableName,
                originalSourceTable: mapping.sourceTable,
                originalSource: mapping.source,
                originalTargetTable: mapping.targetTable,
                originalTarget: mapping.target
            });
            
            // Criar c√≥pia do mapeamento com status de migra√ß√£o e dados corrigidos
            const migrationMapping = {
                ...mapping,
                sourceTable: sourceTableName,
                targetTable: targetTableName,
                source: sourceTableName,
                target: targetTableName,
                validatedAt: mapping.validatedAt || new Date().toISOString(),
                transferredAt: new Date().toISOString(),
                status: 'readyForMigration',
                migrationId: mapping.migrationId || mapping.id || `mig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };
            
            console.log('üìã Objeto de migra√ß√£o criado:', {
                sourceTable: migrationMapping.sourceTable,
                targetTable: migrationMapping.targetTable,
                validatedAt: migrationMapping.validatedAt,
                transferredAt: migrationMapping.transferredAt,
                migrationId: migrationMapping.migrationId,
                columnMappings: migrationMapping.columnMappings?.length || 0,
                status: migrationMapping.status
            });
            
            // Verificar se j√° existe
            const existingIndex = validatedMappings.findIndex(m => 
                (m.migrationId === migrationMapping.migrationId) || 
                (m.sourceTable === sourceTableName && m.targetTable === targetTableName) ||
                (m.id === mapping.id && mapping.id)
            );
            
            console.log('üîç Verifica√ß√£o de duplicata:', {
                existingIndex,
                migrationId: migrationMapping.migrationId,
                searchCriteria: {
                    sourceTable: sourceTableName,
                    targetTable: targetTableName,
                    mappingId: mapping.id
                }
            });
            
            if (existingIndex !== -1) {
                // Atualizar existente
                console.log('üîÑ Atualizando mapeamento existente no √≠ndice:', existingIndex);
                validatedMappings[existingIndex] = migrationMapping;
            } else {
                // Adicionar novo
                console.log('‚ûï Adicionando novo mapeamento √† lista de migra√ß√£o');
                validatedMappings.push(migrationMapping);
            }
            
            console.log('üìä Estado atual do array validatedMappings:');
            console.log('  - Length:', validatedMappings.length);
            console.log('  - Items:', validatedMappings.map(m => ({
                sourceTable: m.sourceTable,
                targetTable: m.targetTable,
                migrationId: m.migrationId
            })));
            
            // Atualizar interface da aba de migra√ß√£o
            console.log('üîÑ Chamando updateMigrationTab()...');
            updateMigrationTab();
            
            console.log('‚úÖ Transfer√™ncia conclu√≠da! Total de mapeamentos prontos:', validatedMappings.length);
        }

        // Atualizar aba de Migra√ß√£o com mapeamentos validados
        function updateMigrationTab() {
            console.log('üîÑ updateMigrationTab - INICIANDO atualiza√ß√£o da aba de migra√ß√£o');
            console.log('üìä Array validatedMappings atual:', validatedMappings);
            console.log('üìä N√∫mero de mapeamentos validados:', validatedMappings.length);
            
            const migrationContent = document.getElementById('migration');
            if (!migrationContent) {
                console.error('‚ùå Elemento #migration n√£o encontrado!');
                alert('‚ùå Erro: Elemento da aba de migra√ß√£o n√£o encontrado!');
                return;
            }

            console.log('‚úÖ Elemento #migration encontrado:', migrationContent);
            console.log('üìä Conte√∫do atual da aba (primeiros 200 chars):', migrationContent.innerHTML.substring(0, 200));

            // Se n√£o h√° mapeamentos validados, mostrar interface padr√£o melhorada
            if (validatedMappings.length === 0) {
                console.log('‚è≥ Nenhum mapeamento validado - mostrando interface padr√£o');
                migrationContent.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <h2>üöÄ Executar Migra√ß√£o</h2>
                        <p style="margin: 20px 0; color: #6c757d;">Configure os mapeamentos antes de iniciar a migra√ß√£o</p>
                        
                        <!-- Status de Mapeamentos -->
                        <div style="margin: 30px 0; padding: 20px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                            <h4 style="color: #856404; margin-bottom: 15px;">‚è≥ Aguardando Mapeamentos Validados</h4>
                            <p style="color: #856404; margin-bottom: 15px;">Nenhum mapeamento foi validado ainda. Para come√ßar:</p>
                            <ol style="text-align: left; color: #856404; max-width: 400px; margin: 0 auto;">
                                <li>V√° para a aba "üéØ Mapeamento Inteligente"</li>
                                <li>Configure os mapeamentos de tabelas e colunas</li>
                                <li>Clique em "‚úÖ Validar Mapeamento"</li>
                                <li>Retorne aqui para executar a migra√ß√£o</li>
                            </ol>
                            <button class="btn btn-primary" onclick="document.querySelector('[data-tab=\\"mapping\\"]').click()" style="margin-top: 15px;">
                                üéØ Ir para Mapeamento
                            </button>
                        </div>
                        
                        <!-- Debug Controls -->
                        <div style="margin: 20px 0; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
                            <p><strong>üîç Debug da Migra√ß√£o:</strong></p>
                            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                                <button class="btn btn-info btn-sm" onclick="debugMigrationState()">
                                    üîç Verificar Estado
                                </button>
                                <button class="btn btn-warning btn-sm" onclick="forceUpdateMigrationTab()">
                                    üîÑ For√ßar Atualiza√ß√£o
                                </button>
                                <button class="btn btn-secondary btn-sm" onclick="console.log('Arrays:', {tableMappings, validatedMappings})">
                                    üìä Log Arrays
                                </button>
                            </div>
                        </div>
                        
                        <div style="margin: 30px 0;">
                            <div class="form-group" style="max-width: 300px; margin: 0 auto;">
                                <label>Tamanho do Lote</label>
                                <input type="number" id="batchSize" value="1000" min="100" max="10000">
                            </div>
                        </div>

                        <button class="btn btn-secondary btn-lg" disabled title="Valide pelo menos um mapeamento primeiro">
                            üöÄ Iniciar Migra√ß√£o Inteligente
                        </button>
                    </div>
                `;
                console.log('‚úÖ Interface padr√£o definida');
                return;
            }

            console.log('‚úÖ Gerando interface com mapeamentos validados...');

            // Criar nova estrutura da aba de migra√ß√£o
            const migrationHTML = `
                <div class="section-title">üöÄ Migra√ß√£o e Transfer√™ncia</div>
                <div class="section-content">
                    
                    <!-- Debug Info -->
                    <div class="debug-info" style="background: #e3f2fd; padding: 10px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #2196f3;">
                        <small><strong>üîç Debug:</strong> ${validatedMappings.length} mapeamento(s) validado(s) encontrado(s) - Atualizado em: ${new Date().toLocaleTimeString()}</small>
                    </div>
                    
                    <!-- Estat√≠sticas de Migra√ß√£o -->
                    <div class="statistics-section">
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-icon">üìã</div>
                                <div class="stat-value">${validatedMappings.length}</div>
                                <div class="stat-label">Prontos para Migra√ß√£o</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">üéØ</div>
                                <div class="stat-value">${validatedMappings.reduce((total, m) => total + (m.columnMappings ? m.columnMappings.length : 0), 0)}</div>
                                <div class="stat-label">Colunas Mapeadas</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-icon">‚úÖ</div>
                                <div class="stat-value">100%</div>
                                <div class="stat-label">Taxa de Valida√ß√£o</div>
                            </div>
                        </div>
                    </div>

                    <!-- Controles de Sele√ß√£o -->
                    <div class="migration-controls">
                        <h4>üéØ Controles de Migra√ß√£o</h4>
                        <div class="button-group">
                            <button class="btn btn-secondary" onclick="selectAllMigrations()" ${validatedMappings.length === 0 ? 'disabled' : ''}>
                                ‚òëÔ∏è Selecionar Todos
                            </button>
                            <button class="btn btn-secondary" onclick="clearMigrationSelection()" disabled id="clearSelectionBtn">
                                ‚ùå Limpar Sele√ß√£o
                            </button>
                            <button class="btn btn-success" onclick="migrateSelected()" disabled id="migrateSelectedBtn">
                                üöÄ Migrar Selecionados
                            </button>
                            <button class="btn btn-info" onclick="debugMigrationState()" title="Verificar estado dos mapeamentos">
                                üîç Debug Estado
                            </button>
                        </div>
                    </div>

                    <!-- Lista de Mapeamentos Prontos -->
                    <div class="validated-mappings-list">
                        <h4>üìä Mapeamentos Validados e Prontos</h4>
                        <div id="readyMappingsList">
                            ${validatedMappings.map((mapping, index) => {
                                // Garantir que temos os nomes das tabelas
                                const sourceTableName = mapping.sourceTable || mapping.source || 'Tabela de Origem';
                                const targetTableName = mapping.targetTable || mapping.target || 'Tabela de Destino';
                                
                                // Garantir que temos datas v√°lidas
                                const validatedDate = mapping.validatedAt ? new Date(mapping.validatedAt) : new Date();
                                const transferredDate = mapping.transferredAt ? new Date(mapping.transferredAt) : new Date();
                                
                                // Verificar se as datas s√£o v√°lidas
                                const validatedDateStr = !isNaN(validatedDate.getTime()) ? validatedDate.toLocaleString('pt-BR') : 'Data n√£o dispon√≠vel';
                                const transferredDateStr = !isNaN(transferredDate.getTime()) ? transferredDate.toLocaleString('pt-BR') : 'Data n√£o dispon√≠vel';
                                
                                const columnCount = mapping.columnMappings ? mapping.columnMappings.length : 0;
                                
                                return `
                                    <div class="migration-mapping-item" data-migration-id="${mapping.migrationId || mapping.id}">
                                        <div class="migration-mapping-header">
                                            <div class="migration-selection">
                                                <input type="checkbox" class="migration-checkbox" id="mig_${index}" onchange="updateMigrationSelection()">
                                            </div>
                                            <div class="migration-mapping-title">
                                                <strong>${sourceTableName}</strong> ‚Üí <strong>${targetTableName}</strong>
                                                <span class="validation-badge validated">‚úÖ VALIDADO</span>
                                            </div>
                                            <div class="migration-mapping-stats">
                                                <span class="badge badge-success">${columnCount} colunas</span>
                                                <span class="badge badge-info">Pronto</span>
                                            </div>
                                        </div>
                                        <div class="migration-mapping-details">
                                            <div class="mapping-summary">
                                                <strong>Validado em:</strong> ${validatedDateStr}
                                                <br>
                                                <strong>Transferido em:</strong> ${transferredDateStr}
                                            </div>
                                            <div class="migration-actions">
                                                <button class="btn btn-sm btn-info" onclick="viewMigrationDetails('${mapping.migrationId || mapping.id}')">
                                                    üìã Detalhes
                                                </button>
                                                <button class="btn btn-sm btn-warning" onclick="returnToMapping('${mapping.migrationId || mapping.id}')">
                                                    ‚¨ÖÔ∏è Voltar para Mapeamento
                                                </button>
                                                <button class="btn btn-sm btn-success" onclick="executeSingleMigration('${mapping.migrationId || mapping.id}')">
                                                    üöÄ Migrar Esta Tabela
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <!-- Configura√ß√µes de Migra√ß√£o -->
                    <div class="migration-settings">
                        <h4>‚öôÔ∏è Configura√ß√µes de Migra√ß√£o</h4>
                        <div class="form-group">
                            <label>Tamanho do Lote</label>
                            <input type="number" id="batchSize" value="1000" min="100" max="10000" class="form-control">
                            <div class="form-text">N√∫mero de registros a processar por vez</div>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="stopOnError" checked> Parar em caso de erro
                            </label>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="logProgress" checked> Log detalhado do progresso
                            </label>
                        </div>
                    </div>

                    <!-- A√ß√µes de Migra√ß√£o -->
                    <div class="migration-actions-section">
                        <div class="button-group center">
                            ${validatedMappings.length > 0 ? `
                                <button class="btn btn-success btn-lg" onclick="startBatchMigration()">
                                    üöÄ Migrar Todas as Tabelas (${validatedMappings.length})
                                </button>
                                <button class="btn btn-secondary" onclick="clearValidatedMappings()">
                                    üßπ Limpar Lista
                                </button>
                            ` : `
                                <button class="btn btn-secondary" disabled>
                                    ‚è≥ Aguardando Mapeamentos Validados
                                </button>
                            `}
                        </div>
                    </div>

                    <!-- Configura√ß√µes de Migra√ß√£o -->
                    <div class="migration-settings">
                        <h4>‚öôÔ∏è Configura√ß√µes de Migra√ß√£o</h4>
                        <div class="form-group">
                            <label>Tamanho do Lote</label>
                            <input type="number" id="batchSize" value="1000" min="100" max="10000" class="form-control">
                            <div class="form-text">N√∫mero de registros a processar por vez</div>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="stopOnError" checked> Parar em caso de erro
                            </label>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="logProgress" checked> Log detalhado do progresso
                            </label>
                        </div>
                    </div>

                    <!-- A√ß√µes de Migra√ß√£o -->
                    <div class="migration-actions-section">
                        <div class="button-group center">
                            <button class="btn btn-success btn-lg" onclick="startBatchMigration()">
                                üöÄ Migrar Todas as Tabelas (${validatedMappings.length})
                            </button>
                            <button class="btn btn-secondary" onclick="clearValidatedMappings()">
                                üßπ Limpar Lista
                            </button>
                        </div>
                    </div>

                    <!-- Status de Migra√ß√£o -->
                    <div id="migrationStatus">
                        <!-- Status ser√° atualizado dinamicamente -->
                    </div>
                </div>
            `;

            console.log('üìä HTML gerado (tamanho):', migrationHTML.length, 'caracteres');
            console.log('üìã HTML cont√©m mapeamentos?', migrationHTML.includes('migration-mapping-item'));

            // Definir o HTML na aba
            migrationContent.innerHTML = migrationHTML;
            
            console.log('‚úÖ HTML da aba de migra√ß√£o atualizado com sucesso');
            console.log('üìä Verifica√ß√£o final: ', {
                validatedMappingsCount: validatedMappings.length,
                htmlLength: migrationHTML.length,
                containsReadyMappingsList: migrationHTML.includes('readyMappingsList'),
                migrationContentExists: !!migrationContent,
                migrationContentInnerHTML: migrationContent.innerHTML.length
            });
        }

        // Fun√ß√£o de debug para verificar estado dos mapeamentos
        function debugMigrationState() {
            console.log('üîç DEBUG - Estado completo dos mapeamentos:');
            console.log('üìä tableMappings (principais):', tableMappings);
            console.log('üìä validatedMappings (migra√ß√£o):', validatedMappings);
            console.log('üìä currentMapping (atual):', currentMapping);
            
            const mappingsInfo = tableMappings.map(m => ({
                sourceTable: m.sourceTable || m.source,
                targetTable: m.targetTable || m.target,
                validated: m.validated,
                validatedAt: m.validatedAt,
                id: m.id
            }));
            
            console.log('üìã Resumo dos mapeamentos principais:', mappingsInfo);
            
            const validatedInfo = validatedMappings.map(m => ({
                sourceTable: m.sourceTable || m.source,
                targetTable: m.targetTable || m.target,
                migrationId: m.migrationId,
                transferredAt: m.transferredAt
            }));
            
            console.log('üìã Resumo dos mapeamentos de migra√ß√£o:', validatedInfo);
            
            // Verificar se existem mapeamentos validados mas n√£o transferidos
            const validatedButNotTransferred = tableMappings.filter(m => 
                m.validated && !validatedMappings.some(vm => 
                    (vm.sourceTable === m.sourceTable && vm.targetTable === m.targetTable) ||
                    (vm.source === m.source && vm.target === m.target)
                )
            );
            
            if (validatedButNotTransferred.length > 0) {
                console.warn('‚ö†Ô∏è Mapeamentos validados mas n√£o transferidos:', validatedButNotTransferred);
                alert(`üîç Encontrados ${validatedButNotTransferred.length} mapeamento(s) validado(s) que n√£o foram transferidos para migra√ß√£o.\n\nVerifique o console para detalhes.`);
                
                // Transferir automaticamente
                validatedButNotTransferred.forEach(mapping => {
                    console.log('üîÑ Transferindo automaticamente:', mapping);
                    transferValidatedMappingToMigration(mapping);
                });
            } else {
                alert(`‚úÖ Estado verificado:\n\nüìä ${tableMappings.length} mapeamento(s) principal(is)\nüìä ${validatedMappings.length} mapeamento(s) pronto(s) para migra√ß√£o\n\n${validatedMappings.length === 0 ? '‚è≥ Nenhum mapeamento validado ainda.' : 'üöÄ Tudo sincronizado!'}`);
            }
        }

        // Fun√ß√£o para for√ßar atualiza√ß√£o da aba de migra√ß√£o
        function forceUpdateMigrationTab() {
            console.log('üîÑ FOR√áANDO atualiza√ß√£o da aba de migra√ß√£o...');
            console.log('üìä Estado atual dos arrays:');
            console.log('  - tableMappings:', tableMappings.length, 'itens');
            console.log('  - validatedMappings:', validatedMappings.length, 'itens');
            
            // Verificar se existem mapeamentos validados que n√£o foram transferidos
            const validatedNotTransferred = tableMappings.filter(m => 
                m.validated && !validatedMappings.some(vm => 
                    (vm.sourceTable === m.sourceTable && vm.targetTable === m.targetTable) ||
                    (vm.source === m.source && vm.target === m.target) ||
                    (vm.id === m.id)
                )
            );
            
            console.log('  - validatedNotTransferred:', validatedNotTransferred.length, 'itens');
            
            if (validatedNotTransferred.length > 0) {
                console.log('üîÑ Transferindo mapeamentos validados n√£o transferidos...');
                validatedNotTransferred.forEach((mapping, index) => {
                    console.log(`  - Transferindo ${index + 1}/${validatedNotTransferred.length}:`, mapping.sourceTable, '‚Üí', mapping.targetTable);
                    transferValidatedMappingToMigration(mapping);
                });
            }
            
            // For√ßar atualiza√ß√£o da interface
            updateMigrationTab();
            
            // Mostrar resultado
            const finalCount = validatedMappings.length;
            alert(`üîÑ Atualiza√ß√£o for√ßada conclu√≠da!\n\nüìä ${finalCount} mapeamento(s) pronto(s) para migra√ß√£o\n\nA interface foi atualizada.`);
            
            // Se estamos na aba de migra√ß√£o, for√ßar re-sele√ß√£o
            const migrationTab = document.querySelector('[data-tab="migration"]');
            if (migrationTab && migrationTab.classList.contains('active')) {
                console.log('üîÑ Re-ativando aba de migra√ß√£o...');
                migrationTab.click();
            }
        }

        // Fun√ß√µes de controle de sele√ß√£o m√∫ltipla para migra√ß√£o
        function selectAllMigrations() {
            const checkboxes = document.querySelectorAll('.migration-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateMigrationSelection();
        }

        function clearMigrationSelection() {
            const checkboxes = document.querySelectorAll('.migration-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateMigrationSelection();
        }

        function updateMigrationSelection() {
            const checkboxes = document.querySelectorAll('.migration-checkbox');
            const checkedBoxes = document.querySelectorAll('.migration-checkbox:checked');
            
            const clearBtn = document.getElementById('clearSelectionBtn');
            const migrateBtn = document.getElementById('migrateSelectedBtn');
            
            if (clearBtn && migrateBtn) {
                const hasSelection = checkedBoxes.length > 0;
                clearBtn.disabled = !hasSelection;
                migrateBtn.disabled = !hasSelection;
                
                if (hasSelection) {
                    migrateBtn.textContent = `üöÄ Migrar Selecionados (${checkedBoxes.length})`;
                } else {
                    migrateBtn.textContent = 'üöÄ Migrar Selecionados';
                }
            }
        }

        function migrateSelected() {
            const checkedBoxes = document.querySelectorAll('.migration-checkbox:checked');
            
            if (checkedBoxes.length === 0) {
                showStatus('‚ùå Nenhum mapeamento selecionado para migra√ß√£o', 'warning');
                return;
            }

            const selectedMappings = [];
            checkedBoxes.forEach(checkbox => {
                const mappingItem = checkbox.closest('.migration-mapping-item');
                if (mappingItem) {
                    const migrationId = mappingItem.dataset.migrationId;
                    const mapping = validatedMappings.find(m => (m.migrationId || m.id) === migrationId);
                    if (mapping) {
                        selectedMappings.push(mapping);
                    }
                }
            });

            if (selectedMappings.length === 0) {
                showStatus('‚ùå Erro ao localizar mapeamentos selecionados', 'error');
                return;
            }

            // Confirmar migra√ß√£o
            const tableNames = selectedMappings.map(m => `${m.sourceTable || m.source} ‚Üí ${m.targetTable || m.target}`).join('\n');
            const confirmMessage = `üöÄ Migrar ${selectedMappings.length} tabela(s)?\n\n${tableNames}`;
            
            if (confirm(confirmMessage)) {
                startBatchMigrationWithSelection(selectedMappings);
            }
        }

        async function startBatchMigrationWithSelection(selectedMappings) {
            showStatus(`üöÄ Iniciando migra√ß√£o de ${selectedMappings.length} tabela(s)...`, 'info');
            
            const migrationStatus = document.getElementById('migrationStatus');
            if (migrationStatus) {
                migrationStatus.innerHTML = `
                    <div class="migration-progress">
                        <h4>üìä Progresso da Migra√ß√£o</h4>
                        <div id="migrationProgressDetails">
                            <p>Preparando migra√ß√£o de ${selectedMappings.length} tabela(s)...</p>
                        </div>
                    </div>
                `;
            }

            try {
                // Simular processo de migra√ß√£o
                for (let i = 0; i < selectedMappings.length; i++) {
                    const mapping = selectedMappings[i];
                    const tableName = mapping.sourceTable || mapping.source || `Tabela ${i + 1}`;
                    
                    // Atualizar status
                    const progressDetails = document.getElementById('migrationProgressDetails');
                    if (progressDetails) {
                        progressDetails.innerHTML = `
                            <p>üîÑ Migrando ${tableName} (${i + 1}/${selectedMappings.length})...</p>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${((i + 1) / selectedMappings.length) * 100}%"></div>
                            </div>
                        `;
                    }
                    
                    // Simular tempo de migra√ß√£o
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                // Sucesso
                showStatus(`‚úÖ Migra√ß√£o conclu√≠da com sucesso! ${selectedMappings.length} tabela(s) migrada(s)`, 'success');
                
                if (migrationStatus) {
                    migrationStatus.innerHTML = `
                        <div class="migration-success">
                            <h4>‚úÖ Migra√ß√£o Conclu√≠da</h4>
                            <p>${selectedMappings.length} tabela(s) migrada(s) com sucesso!</p>
                        </div>
                    `;
                }

                // Limpar sele√ß√£o
                clearMigrationSelection();

            } catch (error) {
                console.error('Erro na migra√ß√£o:', error);
                showStatus(`‚ùå Erro na migra√ß√£o: ${error.message}`, 'error');
            }
        }

        // Fun√ß√µes auxiliares para aba de Migra√ß√£o
        function viewMigrationDetails(migrationId) {
            const mapping = validatedMappings.find(m => m.migrationId === migrationId);
            if (!mapping) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            let detailsHTML = `
                <h3>üìã Detalhes do Mapeamento: ${mapping.sourceTable} ‚Üí ${mapping.targetTable}</h3>
                <div class="mapping-details">
                    <p><strong>Status:</strong> Pronto para Migra√ß√£o ‚úÖ</p>
                    <p><strong>Validado em:</strong> ${new Date(mapping.validatedAt).toLocaleString()}</p>
                    <p><strong>Transferido em:</strong> ${new Date(mapping.transferredAt).toLocaleString()}</p>
                    <p><strong>Colunas mapeadas:</strong> ${mapping.columnMappings ? mapping.columnMappings.length : 0}</p>
                    
                    <h4>Mapeamento de Colunas:</h4>
                    <div class="columns-mapping-preview">
            `;

            if (mapping.columnMappings && mapping.columnMappings.length > 0) {
                mapping.columnMappings.forEach(colMapping => {
                    detailsHTML += `
                        <div class="column-mapping-row">
                            <span class="source-col">${colMapping.sourceColumn}</span>
                            <span class="mapping-arrow">‚Üí</span>
                            <span class="target-col">${colMapping.targetColumn}</span>
                            <span class="type-info">${colMapping.sourceType} ‚Üí ${colMapping.targetType}</span>
                        </div>
                    `;
                });
            } else {
                detailsHTML += '<p>Nenhum mapeamento de coluna espec√≠fico configurado.</p>';
            }

            detailsHTML += `
                    </div>
                </div>
            `;

            showStatus(detailsHTML, 'info');
        }

        function returnToMapping(migrationId) {
            const mapping = validatedMappings.find(m => m.migrationId === migrationId);
            if (!mapping) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            if (confirm(`üîÑ Deseja retornar "${mapping.sourceTable} ‚Üí ${mapping.targetTable}" para a aba de Mapeamento?\n\nEle ser√° removido da lista de migra√ß√£o e poder√° ser editado novamente.`)) {
                // Remover da lista de migra√ß√£o
                const index = validatedMappings.findIndex(m => m.migrationId === migrationId);
                if (index !== -1) {
                    validatedMappings.splice(index, 1);
                }

                // Encontrar na lista principal e desmarcar valida√ß√£o
                const originalMapping = tableMappings.find(m => 
                    m.sourceTable === mapping.sourceTable && m.targetTable === mapping.targetTable
                );
                
                if (originalMapping) {
                    originalMapping.validated = false;
                    delete originalMapping.validatedAt;
                    delete originalMapping.validatedBy;
                }

                // Atualizar interfaces
                updateMigrationTab();
                renderMappings();
                updateTableVisualStatus();
                
                // Ir para aba de mapeamento
                document.querySelector('[data-tab="mapping"]').click();
                
                showStatus(`‚¨ÖÔ∏è Mapeamento retornado: ${mapping.sourceTable} ‚Üí ${mapping.targetTable}`, 'info');
            }
        }

        function executeSingleMigration(migrationId) {
            const mapping = validatedMappings.find(m => m.migrationId === migrationId);
            if (!mapping) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            if (confirm(`üöÄ Iniciar migra√ß√£o de "${mapping.sourceTable}" para "${mapping.targetTable}"?`)) {
                showStatus(`üöÄ Iniciando migra√ß√£o: ${mapping.sourceTable} ‚Üí ${mapping.targetTable}...`, 'info');
                
                // Simular processo de migra√ß√£o (substitua pela implementa√ß√£o real)
                setTimeout(() => {
                    showStatus(`‚úÖ Migra√ß√£o conclu√≠da: ${mapping.sourceTable} ‚Üí ${mapping.targetTable}`, 'success');
                }, 2000);
            }
        }

        function startBatchMigration() {
            if (validatedMappings.length === 0) {
                showStatus('‚ùå Nenhum mapeamento pronto para migra√ß√£o', 'error');
                return;
            }

            if (confirm(`üöÄ Iniciar migra√ß√£o em lote de ${validatedMappings.length} tabela(s)?\n\nEste processo pode demorar alguns minutos.`)) {
                showStatus(`üöÄ Iniciando migra√ß√£o em lote de ${validatedMappings.length} tabelas...`, 'info');
                
                // Simular processo de migra√ß√£o em lote (substitua pela implementa√ß√£o real)
                let completed = 0;
                const total = validatedMappings.length;
                
                const migrateNext = () => {
                    if (completed >= total) {
                        showStatus(`üéâ Migra√ß√£o em lote conclu√≠da! ${total} tabelas migradas com sucesso.`, 'success');
                        return;
                    }
                    
                    const currentMapping = validatedMappings[completed];
                    showStatus(`üîÑ Migrando ${completed + 1}/${total}: ${currentMapping.sourceTable} ‚Üí ${currentMapping.targetTable}...`, 'info');
                    
                    setTimeout(() => {
                        completed++;
                        migrateNext();
                    }, 1500);
                };
                
                migrateNext();
            }
        }

        function clearValidatedMappings() {
            if (validatedMappings.length === 0) {
                showStatus('‚ùå Nenhum mapeamento na lista de migra√ß√£o', 'error');
                return;
            }

            if (confirm(`üßπ Limpar lista de ${validatedMappings.length} mapeamento(s) validado(s)?\n\nEles retornar√£o para a aba de Mapeamento como "n√£o validados".`)) {
                // Desmarcar valida√ß√£o de todos
                validatedMappings.forEach(migMapping => {
                    const originalMapping = tableMappings.find(m => 
                        m.sourceTable === migMapping.sourceTable && m.targetTable === migMapping.targetTable
                    );
                    
                    if (originalMapping) {
                        originalMapping.validated = false;
                        delete originalMapping.validatedAt;
                        delete originalMapping.validatedBy;
                    }
                });

                // Limpar lista de migra√ß√£o
                validatedMappings = [];

                // Atualizar interfaces
                updateMigrationTab();
                renderMappings();
                updateTableVisualStatus();
                
                showStatus('üßπ Lista de migra√ß√£o limpa. Mapeamentos retornaram para valida√ß√£o.', 'info');
            }
        }

        // Wrapper function para validar mapeamento espec√≠fico atrav√©s dos bot√µes
        function validateSpecificMapping(mappingId) {
            const mapping = tableMappings.find(m => (m.id || m.sourceTable) === mappingId);
            if (!mapping) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            // Definir como currentMapping para a fun√ß√£o validateMapping funcionar
            currentMapping = mapping;
            
            // Se n√£o h√° colunas mapeadas, usar edi√ß√£o r√°pida
            if (!mapping.columnMappings || mapping.columnMappings.length === 0) {
                showStatus('‚öôÔ∏è Configurando mapeamento de colunas automaticamente...', 'info');
                
                // Buscar colunas das tabelas
                const sourceTable = sourceSchema.find(t => t.name === mapping.sourceTable);
                const targetTable = targetSchema.find(t => t.name === mapping.targetTable);
                
                if (sourceTable && targetTable) {
                    sourceColumns = sourceTable.columns || [];
                    targetColumns = targetTable.columns || [];
                    
                    // Auto-mapear colunas similares
                    columnMappings = sourceColumns.map(sourceCol => {
                        const targetCol = targetColumns.find(targetCol => 
                            targetCol.name.toLowerCase() === sourceCol.name.toLowerCase() ||
                            targetCol.name.toLowerCase().includes(sourceCol.name.toLowerCase()) ||
                            sourceCol.name.toLowerCase().includes(targetCol.name.toLowerCase())
                        );
                        
                        if (targetCol) {
                            return {
                                sourceColumn: sourceCol.name,
                                targetColumn: targetCol.name,
                                sourceType: sourceCol.type,
                                targetType: targetCol.type,
                                compatible: true
                            };
                        }
                        return null;
                    }).filter(mapping => mapping !== null);
                    
                    // Salvar mapeamentos na estrutura
                    currentMapping.columnMappings = columnMappings;
                }
            } else {
                // Usar mapeamentos existentes
                columnMappings = mapping.columnMappings || [];
                sourceColumns = [];
                targetColumns = [];
            }
            
            // Chamar valida√ß√£o
            validateMapping();
        }

        // Mostrar detalhes do mapeamento
        function showMappingDetails(mappingId) {
            const mapping = tableMappings.find(m => (m.id || m.sourceTable) === mappingId);
            if (!mapping) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            const modal = document.getElementById('mappingDetailsModal');
            const content = document.getElementById('mappingDetailsContent');
            
            content.innerHTML = `
                <div class="mapping-summary">
                    <h4>üìä ${mapping.sourceTable} ‚Üí ${mapping.targetTable}</h4>
                    <p>Confian√ßa: ${Math.round(mapping.confidence)}%</p>
                    <p>Criado em: ${new Date(mapping.createdAt || Date.now()).toLocaleString()}</p>
                </div>
                
                <div class="mapping-stats compact">
                    <div class="stat-item">
                        <div class="stat-value">${mapping.sourceColumns?.length || 0}</div>
                        <div class="stat-label">Origem</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${mapping.targetColumns?.length || 0}</div>
                        <div class="stat-label">Destino</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${mapping.columnMappings?.length || 0}</div>
                        <div class="stat-label">Mapeados</div>
                    </div>
                </div>

                ${mapping.columnMappings && mapping.columnMappings.length > 0 ? `
                    <h4>üîó Mapeamentos de Colunas</h4>
                    <div class="column-mappings-detail">
                        ${mapping.columnMappings.map(col => `
                            <div class="column-mapping-detail">
                                <div class="source-detail">
                                    <strong>${col.sourceColumn}</strong> (${col.sourceType})
                                </div>
                                <div class="arrow-detail">‚Üí</div>
                                <div class="target-detail">
                                    <strong>${col.targetColumn}</strong> (${col.targetType})
                                </div>
                                <div class="compatibility ${col.compatible ? 'compatible' : 'incompatible'}">
                                    ${col.compatible ? '‚úÖ' : '‚ö†Ô∏è'} ${Math.round(col.confidence * 100)}%
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : '<p style="text-align: center; color: #6c757d;">Nenhuma coluna mapeada</p>'}
            `;
            
            modal.style.display = 'block';
        }

        // Fechar modal de detalhes
        function closeMappingDetailsModal() {
            document.getElementById('mappingDetailsModal').style.display = 'none';
        }

        // ==================== INTERFACE AVAN√áADA DE MAPEAMENTOS CONFIGURADOS ====================

        // Alternar entre vis√£o simples e detalhada
        function toggleMappingView(viewType) {
            const simpleView = document.getElementById('simpleMappingView');
            const detailedView = document.getElementById('detailedMappingView');
            const simpleBtn = document.getElementById('simpleViewBtn');
            const detailedBtn = document.getElementById('detailedViewBtn');

            if (viewType === 'simple') {
                simpleView.style.display = 'block';
                detailedView.style.display = 'none';
                simpleBtn.classList.add('active');
                detailedBtn.classList.remove('active');
                renderMappings(); // Renderizar vis√£o simples
            } else {
                simpleView.style.display = 'none';
                detailedView.style.display = 'block';
                simpleBtn.classList.remove('active');
                detailedBtn.classList.add('active');
                renderDetailedMappings(); // Renderizar vis√£o detalhada
            }
        }

        // Renderizar mapeamentos na vis√£o detalhada
        function renderDetailedMappings() {
            const container = document.getElementById('detailedMappingsList');
            if (!container) return;

            // Filtrar apenas mapeamentos n√£o validados para a vis√£o detalhada
            const pendingMappings = tableMappings.filter(mapping => !mapping.validated);

            if (pendingMappings.length === 0) {
                if (tableMappings.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #6c757d;">
                            <div style="font-size: 3rem; margin-bottom: 20px;">üìã</div>
                            <h4>Nenhum mapeamento configurado</h4>
                            <p>Selecione tabelas nas se√ß√µes de esquemas para criar mapeamentos</p>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #28a745;">
                            <div style="font-size: 3rem; margin-bottom: 20px;">‚úÖ</div>
                            <h4>Todos os mapeamentos foram validados!</h4>
                            <p>Os mapeamentos validados est√£o dispon√≠veis na aba <strong>üöÄ Migra√ß√£o</strong></p>
                            <p style="margin-top: 15px; color: #6c757d; font-size: 0.9rem;">
                                Configure novos mapeamentos selecionando outras tabelas ou v√° para a aba Migra√ß√£o para executar a transfer√™ncia.
                            </p>
                        </div>
                    `;
                }
                return;
            }

            container.innerHTML = pendingMappings.map(mapping => createDetailedMappingElement(mapping)).join('');
        }

        // Criar elemento detalhado de mapeamento
        function createDetailedMappingElement(mapping) {
            const sourceTable = sourceSchema.find(t => t.name === mapping.sourceTable);
            const targetTable = targetSchema.find(t => t.name === mapping.targetTable);
            
            if (!sourceTable || !targetTable) {
                return `<div class="alert alert-warning">‚ö†Ô∏è Tabelas n√£o encontradas para o mapeamento ${mapping.sourceTable} ‚Üí ${mapping.targetTable}</div>`;
            }

            const mappedColumns = mapping.columnMappings || [];
            const totalSourceColumns = sourceTable.columns.length;
            const totalTargetColumns = targetTable.columns.length;
            const mappedSourceColumns = mappedColumns.length;
            const unmappedSourceColumns = totalSourceColumns - mappedSourceColumns;
            const mappedTargetColumns = new Set(mappedColumns.map(cm => cm.targetColumn)).size;
            const unmappedTargetColumns = totalTargetColumns - mappedTargetColumns;
            
            const completeness = totalSourceColumns > 0 ? Math.round((mappedSourceColumns / totalSourceColumns) * 100) : 0;

            return `
                <div class="detailed-mapping-item" data-mapping-id="${mapping.id || mapping.sourceTable}">
                    <div class="detailed-mapping-header">
                        <div class="detailed-mapping-title">
                            üìã ${mapping.sourceTable} ‚Üí ${mapping.targetTable}
                        </div>
                        <div class="detailed-mapping-stats">
                            <span>üìä ${mappedSourceColumns}/${totalSourceColumns} colunas</span>
                            <span>üéØ ${completeness}% completo</span>
                            <span class="confidence-badge ${completeness >= 80 ? '' : completeness >= 50 ? 'medium' : 'low'}">
                                ${completeness}%
                            </span>
                        </div>
                    </div>
                    <div class="detailed-mapping-body">
                        <div class="columns-comparison">
                            <!-- Colunas de Origem -->
                            <div class="column-group">
                                <h5>üì§ Origem: ${mapping.sourceTable} (${totalSourceColumns} colunas)</h5>
                                <div class="column-list-detailed">
                                    ${sourceTable.columns.map(col => createDetailedColumnElement(col, 'source', mapping)).join('')}
                                </div>
                            </div>

                            <!-- Controles de Mapeamento -->
                            <div class="mapping-connector">
                                <button class="mapping-arrow-detailed" onclick="autoMapTableColumns('${mapping.id || mapping.sourceTable}')" title="Auto-mapear colunas">
                                    ü§ñ
                                </button>
                                <button class="mapping-arrow-detailed" onclick="clearTableColumnMappings('${mapping.id || mapping.sourceTable}')" title="Limpar mapeamentos">
                                    üóëÔ∏è
                                </button>
                                <button class="mapping-arrow-detailed" onclick="editColumnMapping('${mapping.id || mapping.sourceTable}')" title="Editar detalhado">
                                    ‚úèÔ∏è
                                </button>
                            </div>

                            <!-- Colunas de Destino -->
                            <div class="column-group">
                                <h5>üì• Destino: ${mapping.targetTable} (${totalTargetColumns} colunas)</h5>
                                <div class="column-list-detailed">
                                    ${targetTable.columns.map(col => createDetailedColumnElement(col, 'target', mapping)).join('')}
                                </div>
                            </div>
                        </div>

                        <!-- Estat√≠sticas detalhadas -->
                        <div class="mapping-summary">
                            <h6>üìä Estat√≠sticas do Mapeamento</h6>
                            <div class="mapping-stats compact">
                                <div class="stat-item">
                                    <div class="stat-value">${mappedSourceColumns}</div>
                                    <div class="stat-label">Origem OK</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${unmappedSourceColumns}</div>
                                    <div class="stat-label">Origem Pendente</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${mappedTargetColumns}</div>
                                    <div class="stat-label">Destino Usado</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${unmappedTargetColumns}</div>
                                    <div class="stat-label">Destino Livre</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${completeness}%</div>
                                    <div class="stat-label">Progresso</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Criar elemento detalhado de coluna
        function createDetailedColumnElement(column, type, mapping) {
            const mappedColumn = mapping.columnMappings?.find(cm => 
                type === 'source' ? cm.sourceColumn === column.name : cm.targetColumn === column.name
            );
            
            const isMapped = !!mappedColumn;
            const mappedClass = isMapped ? 'mapped' : 'unmapped';
            let typeDisplay = `<div class="column-type-detailed">${column.type}</div>`;
            let mappingInfo = '';

            if (isMapped) {
                if (type === 'source') {
                    // Para colunas de origem, mostrar como ser√° convertida
                    const targetColumn = mapping.columnMappings.find(cm => cm.sourceColumn === column.name);
                    if (targetColumn) {
                        typeDisplay = formatTypeWithConversion(column.type, targetColumn.targetType);
                        mappingInfo = `<div style="font-size: 0.8rem; color: #28a745; margin-top: 4px;">‚Üí ${targetColumn.targetColumn}</div>`;
                    }
                } else {
                    // Para colunas de destino, mostrar de onde vem
                    const sourceColumn = mapping.columnMappings.find(cm => cm.targetColumn === column.name);
                    if (sourceColumn) {
                        typeDisplay = formatTypeWithConversion(sourceColumn.sourceType, column.type);
                        mappingInfo = `<div style="font-size: 0.8rem; color: #007bff; margin-top: 4px;">‚Üê ${sourceColumn.sourceColumn}</div>`;
                    }
                }
            }

            return `
                <div class="column-item-detailed ${mappedClass}" 
                     draggable="true" 
                     data-column-name="${column.name}" 
                     data-column-type="${column.type}"
                     data-table-type="${type}"
                     data-mapping-id="${mapping.id || mapping.sourceTable}"
                     ondragstart="handleDetailedColumnDragStart(event)"
                     ondragover="handleDetailedColumnDragOver(event)"
                     ondrop="handleDetailedColumnDrop(event)">
                    <div>
                        <div class="column-name-detailed">${column.name}</div>
                        ${typeDisplay}
                        ${mappingInfo}
                    </div>
                </div>
            `;
        }

        // Handlers de drag and drop para colunas detalhadas
        function handleDetailedColumnDragStart(event) {
            const columnData = {
                name: event.target.dataset.columnName,
                type: event.target.dataset.columnType,
                tableType: event.target.dataset.tableType,
                mappingId: event.target.dataset.mappingId
            };
            event.dataTransfer.setData('text/plain', JSON.stringify(columnData));
            event.target.classList.add('dragging');
        }

        function handleDetailedColumnDragOver(event) {
            event.preventDefault();
            event.target.classList.add('drop-target');
        }

        function handleDetailedColumnDrop(event) {
            event.preventDefault();
            event.target.classList.remove('drop-target');
            
            try {
                const sourceData = JSON.parse(event.dataTransfer.getData('text/plain'));
                const targetData = {
                    name: event.target.dataset.columnName,
                    type: event.target.dataset.columnType,
                    tableType: event.target.dataset.tableType,
                    mappingId: event.target.dataset.mappingId
                };

                // Verificar se √© um mapeamento v√°lido (origem ‚Üí destino)
                if (sourceData.tableType === targetData.tableType || sourceData.mappingId !== targetData.mappingId) {
                    showStatus('‚ùå Mapeamento inv√°lido: deve ser origem ‚Üí destino na mesma tabela', 'error');
                    return;
                }

                // Criar mapeamento de coluna
                createDetailedColumnMapping(sourceData, targetData);
                
            } catch (error) {
                showStatus('‚ùå Erro no mapeamento: ' + error.message, 'error');
            }
            
            // Limpar classes de drag
            document.querySelectorAll('.column-item-detailed.dragging').forEach(el => {
                el.classList.remove('dragging');
            });
        }

        // Criar mapeamento detalhado de coluna
        function createDetailedColumnMapping(sourceData, targetData) {
            const mappingIndex = tableMappings.findIndex(m => (m.id || m.sourceTable) === sourceData.mappingId);
            if (mappingIndex === -1) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            const mapping = tableMappings[mappingIndex];
            if (!mapping.columnMappings) {
                mapping.columnMappings = [];
            }

            // Verificar se j√° existe mapeamento para esta coluna de origem
            const existingIndex = mapping.columnMappings.findIndex(cm => cm.sourceColumn === sourceData.name);
            
            // Obter informa√ß√µes de convers√£o
            const conversion = getTypeConversion(sourceData.type, targetData.type);
            const compatibilityInfo = typesAreCompatible(sourceData.type, targetData.type);
            
            const newColumnMapping = {
                sourceColumn: sourceData.name,
                targetColumn: targetData.name,
                sourceType: sourceData.type,
                targetType: targetData.type,
                compatible: compatibilityInfo.compatible,
                requiresConversion: compatibilityInfo.requiresConversion,
                conversionType: compatibilityInfo.conversionType,
                confidence: calculateColumnCompatibility(
                    { name: sourceData.name, type: sourceData.type },
                    { name: targetData.name, type: targetData.type }
                ),
                conversion: conversion  // Adicionar informa√ß√µes de convers√£o
            };

            if (existingIndex >= 0) {
                mapping.columnMappings[existingIndex] = newColumnMapping;
                const conversionNote = conversion.note || 'Mapeamento atualizado';
                showStatus(`üîÑ ${conversionNote}: ${sourceData.name} ‚Üí ${targetData.name}`, 'info');
            } else {
                mapping.columnMappings.push(newColumnMapping);
                const conversionNote = conversion.note || 'Mapeamento criado';
                showStatus(`‚úÖ ${conversionNote}: ${sourceData.name} ‚Üí ${targetData.name}`, 'success');
            }

            // Re-renderizar vis√£o detalhada
            renderDetailedMappings();
            updateTableVisualStatus();
        }

        // Auto-mapear colunas de uma tabela espec√≠fica
        function autoMapTableColumns(mappingId) {
            const mappingIndex = tableMappings.findIndex(m => (m.id || m.sourceTable) === mappingId);
            if (mappingIndex === -1) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            const mapping = tableMappings[mappingIndex];
            const sourceTable = sourceSchema.find(t => t.name === mapping.sourceTable);
            const targetTable = targetSchema.find(t => t.name === mapping.targetTable);

            if (!sourceTable || !targetTable) {
                showStatus('‚ùå Tabelas n√£o encontradas', 'error');
                return;
            }

            let mappedCount = 0;
            mapping.columnMappings = [];

            for (const sourceColumn of sourceTable.columns) {
                // Procurar coluna de destino com nome similar
                const targetColumn = targetTable.columns.find(targetCol =>
                    targetCol.name.toLowerCase() === sourceColumn.name.toLowerCase() ||
                    targetCol.name.toLowerCase().includes(sourceColumn.name.toLowerCase()) ||
                    sourceColumn.name.toLowerCase().includes(targetCol.name.toLowerCase())
                );

                if (targetColumn) {
                    const conversion = getTypeConversion(sourceColumn.type, targetColumn.type);
                    const compatibilityInfo = typesAreCompatible(sourceColumn.type, targetColumn.type);
                    mapping.columnMappings.push({
                        sourceColumn: sourceColumn.name,
                        targetColumn: targetColumn.name,
                        sourceType: sourceColumn.type,
                        targetType: targetColumn.type,
                        compatible: compatibilityInfo.compatible,
                        requiresConversion: compatibilityInfo.requiresConversion,
                        conversionType: compatibilityInfo.conversionType,
                        confidence: calculateColumnCompatibility(sourceColumn, targetColumn),
                        conversion: conversion
                    });
                    mappedCount++;
                }
            }

            renderDetailedMappings();
            updateTableVisualStatus();
            showStatus(`ü§ñ Auto-mapeamento conclu√≠do: ${mappedCount} colunas mapeadas`, 'success');
        }

        // Limpar mapeamentos de colunas de uma tabela
        function clearTableColumnMappings(mappingId) {
            const mappingIndex = tableMappings.findIndex(m => (m.id || m.sourceTable) === mappingId);
            if (mappingIndex === -1) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            if (confirm('Tem certeza que deseja limpar todos os mapeamentos de colunas desta tabela?')) {
                tableMappings[mappingIndex].columnMappings = [];
                renderDetailedMappings();
                updateTableVisualStatus();
                showStatus('üóëÔ∏è Mapeamentos de colunas limpos', 'info');
            }
        }

        // ==================== FIM DA INTERFACE AVAN√áADA ====================

        // Remover mapeamento
        function removeMapping(mappingId) {
            const index = tableMappings.findIndex(m => (m.id || m.sourceTable) === mappingId);
            if (index === -1) {
                showStatus('‚ùå Mapeamento n√£o encontrado', 'error');
                return;
            }

            if (confirm('Tem certeza que deseja remover este mapeamento?')) {
                tableMappings.splice(index, 1);
                renderMappings();
                renderDetailedMappings(); // Atualizar tamb√©m a vis√£o detalhada
                updateTableVisualStatus();
                showStatus('üóëÔ∏è Mapeamento removido', 'info');
            }
        }

        // ==================== FIM DO SISTEMA DE MAPEAMENTO DE COLUNAS ====================

        function showStatus(message, type = 'info') {
            console.log(`üì¢ Status: [${type.toUpperCase()}] ${message}`);
            
            const panel = document.getElementById('statusPanel');
            const content = document.getElementById('statusContent');
            
            if (!panel || !content) {
                console.error('‚ùå Elementos de status n√£o encontrados');
                // Fallback: exibir no console
                console.log(`STATUS FALLBACK: ${message}`);
                return;
            }
            
            content.textContent = message;
            panel.style.display = 'block';

            // Auto-hide ap√≥s alguns segundos
            setTimeout(() => {
                panel.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html>
